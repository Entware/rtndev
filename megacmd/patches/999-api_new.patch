--- a/configure.ac
+++ b/configure.ac
@@ -20,6 +20,7 @@
 
 m4_include([sdk/m4/ax_check_compile_flag.m4])
 m4_include([sdk/m4/ax_check_link_flag.m4])
+m4_include([sdk/m4/ax_cxx_compile_stdcxx.m4])
 
 m4_define([megacmd_major_version], [$(cat src/megacmdversion.h | grep "define MEGACMD_MAJOR" | cut -d" " -f 3)])
 m4_define([megacmd_minor_version], [$(cat src/megacmdversion.h | grep "define MEGACMD_MINOR" | cut -d" " -f 3)])
@@ -103,6 +104,9 @@ AM_CONDITIONAL(CPPCHECK, test -n "$HAVE_
 # set C++
 AC_LANG_CPLUSPLUS
 
+# Check for C++11 standard
+AX_CXX_COMPILE_STDCXX([11], [noext], [mandatory], [default])
+
 # Check headers
 AC_STDC_HEADERS
 AC_HEADER_STDC
--- a/src/client/megacmdclient.cpp
+++ b/src/client/megacmdclient.cpp
@@ -24,6 +24,9 @@
 #include <iostream>
 #include <string>
 #include <vector>
+#include <algorithm>
+#include <mutex>
+#include <condition_variable>
 #include <memory.h>
 #include <limits.h>
 
@@ -49,11 +52,12 @@
 #define PROGRESS_COMPLETE -2
 #define SPROGRESS_COMPLETE "-2"
 
-using namespace std;
 
 #define SSTR( x ) static_cast< const std::ostringstream & >( \
         (  std::ostringstream() << std::dec << x ) ).str()
 
+namespace  megacmd {
+using namespace std;
 void printprogress(long long completed, long long total, const char *title = "TRANSFERRING");
 
 #ifdef _WIN32
@@ -140,6 +144,11 @@ wstring getWAbsPath(wstring localpath)
 
 string clientID; //identifier for a registered state listener
 
+std::mutex promptLogReceivedMutex;
+std::condition_variable promtpLogReceivedCV;
+bool promtpLogReceivedBool = false;
+bool serverTryingToLog = false;
+
 string getAbsPath(string relativePath)
 {
     if (!relativePath.size())
@@ -222,6 +231,13 @@ string parseArgs(int argc, char* argv[])
     {
         absolutedargs.push_back(argv[1]);
 
+        if ( strcmp(argv[1],"quit") && strcmp(argv[1],"exit") )
+        {
+            string clientWidth = "--client-width=";
+            clientWidth+= SSTR(getNumberOfCols(80));
+            absolutedargs.push_back(clientWidth);
+        }
+
         if (!strcmp(argv[1],"get")
                 || !strcmp(argv[1],"put")
                 || !strcmp(argv[1],"login")
@@ -439,6 +455,15 @@ wstring parsewArgs(int argc, wchar_t* ar
     {
         absolutedargs.push_back(argv[1]);
 
+        if ( wcscmp(argv[1],L"quit") && wcscmp(argv[1],L"exit") )
+        {
+            wstring clientWidth = L"--client-width=";
+            string scw = SSTR(getNumberOfCols(80));
+            std::wstring wsclientWidth(scw.begin(), scw.end());
+            clientWidth+=wsclientWidth;
+            absolutedargs.push_back(clientWidth);
+        }
+
         if (!wcscmp(argv[1],L"get")
                 || !wcscmp(argv[1],L"put")
                 || !wcscmp(argv[1],L"login")
@@ -695,6 +720,9 @@ void statechangehandle(string statestrin
     size_t nextstatedelimitpos = statestring.find(statedelim);
     static bool shown_partial_progress = false;
 
+    unsigned int width = getNumberOfCols(80);
+    if (width > 1 ) width--;
+
     while (nextstatedelimitpos!=string::npos && statestring.size())
     {
         string newstate = statestring.substr(0,nextstatedelimitpos);
@@ -702,7 +730,9 @@ void statechangehandle(string statestrin
         nextstatedelimitpos = statestring.find(statedelim);
         if (newstate.compare(0, strlen("prompt:"), "prompt:") == 0)
         {
-            //ignore prompt state
+            std::unique_lock<std::mutex> lk(promptLogReceivedMutex);
+            promtpLogReceivedCV.notify_one(); //This is always received after server is first ready
+            promtpLogReceivedBool = true;
         }
         else if (newstate.compare(0, strlen("endtransfer:"), "endtransfer:") == 0)
         {
@@ -735,11 +765,22 @@ void statechangehandle(string statestrin
 #endif
             }
         }
+        else if (newstate.compare(0, strlen("loged:"), "loged:") == 0)
+        {
+            serverTryingToLog = false;
+            promtpLogReceivedCV.notify_one();
+            promtpLogReceivedBool = true;
+        }
+        else if (newstate.compare(0, strlen("login:"), "login:") == 0)
+        {
+            serverTryingToLog = true;
+            std::unique_lock<std::mutex> lk(MegaCmdShellCommunications::megaCmdStdoutputing);
+            printCenteredContentsCerr(string("Resuming session ... ").c_str(), width, false);
+        }
         else if (newstate.compare(0, strlen("message:"), "message:") == 0)
         {
             string contents = newstate.substr(strlen("message:"));
-            unsigned int width = getNumberOfCols(80);
-            if (width > 1 ) width--;
+
             MegaCmdShellCommunications::megaCmdStdoutputing.lock();
             if (shown_partial_progress)
             {
@@ -834,7 +875,9 @@ void statechangehandle(string statestrin
     }
 }
 
+} //end namespace
 
+using namespace megacmd;
 
 int main(int argc, char* argv[])
 {
@@ -865,15 +908,41 @@ int main(int argc, char* argv[])
     MegaCmdShellCommunications *comms = new MegaCmdShellCommunications();
 #endif
 
-    comms->registerForStateChanges(statechangehandle);
+    string command = argv[1];
+    int registerResult = comms->registerForStateChanges(false, statechangehandle, command.compare(0,4,"exit") && command.compare(0,4,"quit") && command.compare(0,10,"completion"));
+    if (registerResult == -1)
+    {
+        return -2;
+    }
 
 #ifdef _WIN32
     int wargc;
     LPWSTR *szArglist = CommandLineToArgvW(GetCommandLineW(),&wargc);
-    wstring wcommand = parsewArgs(wargc,szArglist);
-    int outcode = comms->executeCommandW(wcommand, readresponse, COUT, false);
+    wstring wParsedArgs = parsewArgs(wargc,szArglist);
 #else
     string parsedArgs = parseArgs(argc,argv);
+#endif
+    bool isInloginInValidCommands = false;
+    if (argc>1)
+    {
+        isInloginInValidCommands = std::find(loginInValidCommands.begin(), loginInValidCommands.end(), string(argv[1])) != loginInValidCommands.end();
+    }
+
+    //now we can relay on having a prompt received if the server is running
+    //after that first prompt, we will keep on waiting for server to finish logging in (resuming session)
+    //if the requested command is not allowed. For other commands (e.g. proxy), we let the execution continue
+    do {
+        std::unique_lock<std::mutex> lk(promptLogReceivedMutex);
+        if (!promtpLogReceivedBool)
+        {
+            promtpLogReceivedCV.wait(lk);
+        }
+    } while (serverTryingToLog && !isInloginInValidCommands);
+
+
+#ifdef _WIN32
+    int outcode = comms->executeCommandW(wParsedArgs, readresponse, COUT, false);
+#else
     int outcode = comms->executeCommand(parsedArgs, readresponse, COUT, false);
 #endif
 
--- a/src/client/megacmd_completion.sh
+++ b/src/client/megacmd_completion.sh
@@ -16,7 +16,7 @@ _megacmd()
 			lastcharina="${a: -1}"
 			#add trailing space if ended in \ (it would have been strimmed)
 			#and unescape symbols that dont need scaping between single quotes
-			linetoexec=$linetoexec" '"$(echo $a | sed 's#\([^\\]\)\\$#\1\\ #g' | sed "s#\\\\\([ \<\>\|\`;\"\!]\)#\1#g")"'"
+			linetoexec=$linetoexec" '"$(echo $a | sed 's#\([^\\]\)\\$#\1\\ #g' | sed "s#\\\\\([ \<\>\|\`;:\"\!]\)#\1#g")"'"
 		else
 			if [[ ${a} == '=' ]] || [[ ${lasta} == '=' ]] || [[ ${a} == ':' ]] || [[ ${lasta} == ':' ]]; then
 				linetoexec=$linetoexec$a
@@ -53,7 +53,7 @@ _megacmd()
 	#escape characters that need to be scaped
 	for a in `seq 0 $(( ${#aOPTS[@]} -1 ))`; do
 		if [[ $lasta != "\""* ]] && [[ $lasta != "'"* ]]; then
-			COMPREPLY[$a]=$( echo ${aOPTS[$a]} | sed "s#\([ \!;\|\`\(\)\<\>\"\'\\]\)#\\\\\1#g") #OK
+			COMPREPLY[$a]=$( echo ${aOPTS[$a]} | sed "s#\([ \!;:\|\`\(\)\<\>\"\'\\]\)#\\\\\1#g") #OK
 		else
 			COMPREPLY[$a]="${aOPTS[$a]}"
 		fi
--- a/src/comunicationsmanager.cpp
+++ b/src/comunicationsmanager.cpp
@@ -18,9 +18,9 @@
 
 #include "comunicationsmanager.h"
 
-using namespace std;
 using namespace mega;
 
+namespace megacmd {
 OUTSTREAMTYPE &operator<<(OUTSTREAMTYPE &os, const CmdPetition& p)
 {
     return os << p.line;
@@ -69,7 +69,7 @@ int ComunicationsManager::get_next_comm_
     return 0;
 }
 
-void ComunicationsManager::informStateListeners(string &s)
+bool ComunicationsManager::informStateListeners(string &s)
 {
     s+=(char)0x1F;
 
@@ -85,6 +85,12 @@ void ComunicationsManager::informStateLi
              ++it;
         }
     }
+
+    if (!stateListenersPetitions.size())
+    {
+        return false;
+    }
+    return true;
 }
 
 void ComunicationsManager::informStateListenerByClientId(string &s, int clientID)
@@ -171,3 +177,4 @@ void CmdPetition::setPetitionThread(Mega
 {
     petitionThread = value;
 }
+}//end namespace
--- a/src/comunicationsmanagerfilesockets.cpp
+++ b/src/comunicationsmanagerfilesockets.cpp
@@ -29,14 +29,12 @@
 #endif
 
 using namespace mega;
-using namespace std;
 
+namespace megacmd {
 int ComunicationsManagerFileSockets::get_next_comm_id()
 {
-    mtx->lock();
-    ++count;
-    mtx->unlock();
-    return count;
+    std::lock_guard<std::mutex> g(informerMutex);
+    return ++count;
 }
 
 int ComunicationsManagerFileSockets::create_new_socket(int *sockId)
@@ -134,15 +132,11 @@ int ComunicationsManagerFileSockets::cre
 ComunicationsManagerFileSockets::ComunicationsManagerFileSockets()
 {
     count = 0;
-    mtx = new MegaMutex();
-    informerMutex = new MegaMutex(false);
     initialize();
 }
 
 int ComunicationsManagerFileSockets::initialize()
 {
-    mtx->init(false);
-
     MegaFileSystemAccess *fsAccess = new MegaFileSystemAccess();
     char csocketsFolder[34]; // enough to hold all numbers up to 64-bits
     sprintf(csocketsFolder, "/tmp/megaCMD_%d", getuid());
@@ -297,7 +291,7 @@ void ComunicationsManagerFileSockets::re
  */
 void ComunicationsManagerFileSockets::returnAndClosePetition(CmdPetition *inf, OUTSTRINGSTREAM *s, int outCode)
 {
-    LOG_verbose << "Output to write in socket " << ((CmdPetitionPosixSockets *)inf)->outSocket << ": <<" << s->str() << ">>";
+    LOG_verbose << "Output to write in socket " << ((CmdPetitionPosixSockets *)inf)->outSocket;
     sockaddr_in cliAddr;
     socklen_t cliLength = sizeof( cliAddr );
     int connectedsocket = ((CmdPetitionPosixSockets *)inf)->acceptedOutSocket;
@@ -394,7 +388,7 @@ void ComunicationsManagerFileSockets::se
 
 int ComunicationsManagerFileSockets::informStateListener(CmdPetition *inf, string &s)
 {
-    MutexGuard g(*informerMutex);
+    std::lock_guard<std::mutex> g(informerMutex);
     LOG_verbose << "Inform State Listener: Output to write in socket " << ((CmdPetitionPosixSockets *)inf)->outSocket << ": <<" << s << ">>";
 
     sockaddr_in cliAddr;
@@ -445,7 +439,7 @@ int ComunicationsManagerFileSockets::inf
     {
         if (errno == 32) //socket closed
         {
-            LOG_debug << "Unregistering no longer listening client. Original petition: " << *inf;
+            LOG_debug << "Unregistering no longer listening client. Original petition: " << inf->line;
             connectedsockets.erase(((CmdPetitionPosixSockets *)inf)->outSocket);
             return -1;
         }
@@ -465,7 +459,7 @@ int ComunicationsManagerFileSockets::inf
     {
         if (errno == 32) //socket closed
         {
-            LOG_debug << "Unregistering no longer listening client. Original petition: " << *inf;
+            LOG_debug << "Unregistering no longer listening client. Original petition: " << inf->line;
             close(connectedsocket);
             connectedsockets.erase(((CmdPetitionPosixSockets *)inf)->outSocket);
             return -1;
@@ -665,6 +659,5 @@ string ComunicationsManagerFileSockets::
 
 ComunicationsManagerFileSockets::~ComunicationsManagerFileSockets()
 {
-    delete mtx;
-    delete informerMutex;
 }
+}//end namespace
--- a/src/comunicationsmanagerfilesockets.h
+++ b/src/comunicationsmanagerfilesockets.h
@@ -23,6 +23,7 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 
+namespace megacmd {
 class CmdPetitionPosixSockets: public CmdPetition
 {
 public:
@@ -58,8 +59,8 @@ private:
 
     // to get next socket id
     int count;
-    mega::MegaMutex *mtx;
-    mega::MegaMutex *informerMutex;
+    std::mutex mtx;
+    std::mutex informerMutex;
 
     /**
      * @brief create_new_socket
@@ -113,5 +114,5 @@ public:
     ~ComunicationsManagerFileSockets();
 };
 
-
+}//end namespace
 #endif // COMUNICATIONSMANAGERPOSIX_H
--- a/src/comunicationsmanager.h
+++ b/src/comunicationsmanager.h
@@ -22,6 +22,7 @@
 #include "megacmd.h"
 #include "megacmdcommonutils.h"
 
+namespace megacmd {
 static const int MAXCMDSTATELISTENERS = 300;
 
 class CmdPetition
@@ -29,7 +30,7 @@ class CmdPetition
     public:
         char * line;
         mega::MegaThread * petitionThread;
-        int clientID;
+        int clientID = -27;
         bool clientDisconnected;
 
         CmdPetition()
@@ -93,8 +94,9 @@ public:
     /**
      * @brief Sends an status message (e.g. prompt:who@/new/prompt:) to all registered listeners
      * @param s
+     * @returns if state listeners left
      */
-    void informStateListeners(std::string &s);
+    bool informStateListeners(std::string &s);
 
     void informStateListenerByClientId(std::string &s, int clientID);
 
@@ -127,4 +129,5 @@ public:
     virtual ~ComunicationsManager();
 };
 
+} //end namespace
 #endif // COMUNICATIONSMANAGER_H
--- a/src/comunicationsmanagernamedpipes.cpp
+++ b/src/comunicationsmanagernamedpipes.cpp
@@ -21,6 +21,7 @@
 #include "megacmdutils.h"
 
 
+#include <winsock2.h>
 #include <windows.h>
 #include <Lmcons.h> //getusername
 
@@ -32,6 +33,7 @@ using std::wstring;
 using namespace mega;
 
 
+namespace megacmd {
 bool namedPipeValid(HANDLE namedPipe)
 {
     return namedPipe != INVALID_HANDLE_VALUE;
@@ -128,15 +130,13 @@ HANDLE ComunicationsManagerNamedPipes::c
 ComunicationsManagerNamedPipes::ComunicationsManagerNamedPipes()
 {
     count = 0;
-    mtx = new MegaMutex();
-    informerMutex = new MegaMutex(false);
+    mtx = new std::mutex();
+    informerMutex = new std::mutex();
     initialize();
 }
 
 int ComunicationsManagerNamedPipes::initialize()
 {
-    mtx->init(false);
-
     petitionready = false;
 
     wchar_t username[UNLEN+1];
@@ -229,7 +229,7 @@ void ComunicationsManagerNamedPipes::ret
 {
     HANDLE outNamedPipe = ((CmdPetitionNamedPipes *)inf)->outNamedPipe;
 
-    LOG_verbose << "Output to write in namedPipe " << outNamedPipe << ": <<" << s->str() << ">>";
+    LOG_verbose << "Output to write in namedPipe " << (long)outNamedPipe;
 
     bool connectsucceeded = false;
     int attempts = 10;
@@ -284,6 +284,11 @@ void ComunicationsManagerNamedPipes::ret
 
 void ComunicationsManagerNamedPipes::sendPartialOutput(CmdPetition *inf, OUTSTRING *s)
 {
+    if (inf->clientDisconnected)
+    {
+        return;
+    }
+
     HANDLE outNamedPipe = ((CmdPetitionNamedPipes *)inf)->outNamedPipe;
 
     bool connectsucceeded = false;
@@ -416,7 +421,7 @@ void ComunicationsManagerNamedPipes::sen
 
 int ComunicationsManagerNamedPipes::informStateListener(CmdPetition *inf, string &s)
 {
-    MutexGuard g(*informerMutex);
+    std::lock_guard<std::mutex> g(*informerMutex);
 
     LOG_verbose << "Inform State Listener: Output to write in namedPipe " << ((CmdPetitionNamedPipes *)inf)->outNamedPipe << ": <<" << s << ">>";
     HANDLE outNamedPipe = ((CmdPetitionNamedPipes *)inf)->outNamedPipe;
@@ -444,7 +449,7 @@ int ComunicationsManagerNamedPipes::info
     {
         if (ERRNO == 32 || ERRNO == 109 || (ERRNO == 232 && s == "ack")) //namedPipe closed | pipe has been ended
         {
-            LOG_debug << "namedPipe closed. Client probably disconnected. Original petition: " << *inf;
+            LOG_debug << "namedPipe closed. Client probably disconnected. Original petition: " << inf->line;
             return -1;
         }
         else
@@ -623,5 +628,6 @@ ComunicationsManagerNamedPipes::~Comunic
     delete mtx;
     delete informerMutex;
 }
+}//end namespace
 #endif
 
--- a/src/comunicationsmanagernamedpipes.h
+++ b/src/comunicationsmanagernamedpipes.h
@@ -21,11 +21,13 @@
 #include "comunicationsmanager.h"
 
 #include <sys/types.h>
+#include <winsock2.h>
 #include <windows.h>
 
 
 #define MEGACMDINITIALPORTNUMBER 12300
 
+namespace megacmd {
 class CmdPetitionNamedPipes: public CmdPetition
 {
 public:
@@ -57,8 +59,8 @@ private:
 
     // to get next namedPipe id
     int count;
-    mega::MegaMutex *mtx;
-    mega::MegaMutex *informerMutex;
+    std::mutex *mtx;
+    std::mutex *informerMutex;
 
     /**
      * @brief create_new_namedPipe
@@ -115,5 +117,5 @@ public:
 
 };
 
-
+}//end namespace
 #endif // COMUNICATIONSMANAGERPOSIX_H
--- a/src/comunicationsmanagerportsockets.cpp
+++ b/src/comunicationsmanagerportsockets.cpp
@@ -39,8 +39,8 @@
 #endif
 
 using namespace mega;
-using namespace std;
 
+namespace megacmd {
 void closeSocket(SOCKET socket){
 #ifdef _WIN32
     closesocket(socket);
@@ -161,13 +161,12 @@ SOCKET ComunicationsManagerPortSockets::
 ComunicationsManagerPortSockets::ComunicationsManagerPortSockets()
 {
     count = 0;
-    mtx = new MegaMutex();
+    mtx = new std::mutex();
     initialize();
 }
 
 int ComunicationsManagerPortSockets::initialize()
 {
-    mtx->init(false);
 #if _WIN32
     WORD wVersionRequested;
     WSADATA wsaData;
@@ -294,7 +293,7 @@ void ComunicationsManagerPortSockets::re
  */
 void ComunicationsManagerPortSockets::returnAndClosePetition(CmdPetition *inf, OUTSTRINGSTREAM *s, int outCode)
 {
-    LOG_verbose << "Output to write in socket " << ((CmdPetitionPortSockets *)inf)->outSocket << ": <<" << s->str() << ">>";
+    LOG_verbose << "Output to write in socket " << (long)((CmdPetitionPortSockets *)inf)->outSocket;
     sockaddr_in cliAddr;
     socklen_t cliLength = sizeof( cliAddr );
     SOCKET connectedsocket = ((CmdPetitionPortSockets *)inf)->acceptedOutSocket;
@@ -305,7 +304,7 @@ void ComunicationsManagerPortSockets::re
     }
     if (connectedsocket == SOCKET_ERROR)
     {
-        LOG_fatal << "Return and close: Unable to accept on outsocket " << ((CmdPetitionPortSockets *)inf)->outSocket << " error: " << ERRNO;
+        LOG_fatal << "Return and close: Unable to accept on outsocket " << (long)((CmdPetitionPortSockets *)inf)->outSocket << " error: " << ERRNO;
         delete inf;
         return;
     }
@@ -391,7 +390,7 @@ int ComunicationsManagerPortSockets::inf
     {
         if (errno == 32) //socket closed
         {
-            LOG_debug << "Unregistering no longer listening client. Original petition: " << *inf;
+            LOG_debug << "Unregistering no longer listening client. Original petition: " << inf->line;
             closeSocket(connectedsocket);
             connectedsockets.erase(((CmdPetitionPortSockets *)inf)->outSocket);
             return -1;
@@ -412,7 +411,7 @@ int ComunicationsManagerPortSockets::inf
     {
         if (errno == 32) //socket closed
         {
-            LOG_debug << "Unregistering no longer listening client. Original petition: " << *inf;
+            LOG_debug << "Unregistering no longer listening client. Original petition: " << inf->line;
             connectedsockets.erase(((CmdPetitionPortSockets *)inf)->outSocket);
             return -1;
         }
@@ -611,3 +610,4 @@ ComunicationsManagerPortSockets::~Comuni
 #endif
     delete mtx;
 }
+}//end namespace
--- a/src/comunicationsmanagerportsockets.h
+++ b/src/comunicationsmanagerportsockets.h
@@ -30,6 +30,7 @@ typedef int SOCKET;
 #define MEGACMDINITIALPORTNUMBER 12300
 
 
+namespace megacmd {
 void closeSocket(SOCKET socket);
 
 class CmdPetitionPortSockets: public CmdPetition
@@ -69,7 +70,7 @@ private:
 
     // to get next socket id
     int count;
-    mega::MegaMutex *mtx;
+    std::mutex *mtx;
 
     /**
      * @brief create_new_socket
@@ -119,5 +120,5 @@ public:
     ~ComunicationsManagerPortSockets();
 };
 
-
+}//end namespace
 #endif // COMUNICATIONSMANAGERPOSIX_H
--- a/src/configurationmanager.cpp
+++ b/src/configurationmanager.cpp
@@ -40,9 +40,10 @@
 #define unlink _unlink
 #endif
 
-using namespace std;
 using namespace mega;
 
+namespace megacmd {
+using namespace std;
 bool is_file_exist(const char *fileName)
 {
     std::ifstream infile(fileName);
@@ -761,3 +762,4 @@ void ConfigurationManager::clearConfigur
         }
     }
 }
+}//end namespace
--- a/src/configurationmanager.h
+++ b/src/configurationmanager.h
@@ -28,6 +28,7 @@
 #endif
 
 #define CONFIGURATIONSTOREDBYVERSION -2
+namespace megacmd {
 class ConfigurationManager
 {
 private:
@@ -237,5 +238,5 @@ public:
 
 };
 
-
+}//end namespace
 #endif // CONFIGURATIONMANAGER_H
--- a/src/listeners.cpp
+++ b/src/listeners.cpp
@@ -21,8 +21,9 @@
 #include "megacmdutils.h"
 
 using namespace mega;
-using namespace std;
 
+
+namespace megacmd {
 #ifdef ENABLE_CHAT
 void MegaCmdGlobalListener::onChatsUpdate(MegaApi*, MegaTextChatList*)
 {
@@ -201,10 +202,13 @@ void MegaCmdGlobalListener::onEvent(Mega
             {
                 ConfigurationManager::savePropertyValue("ask4storage",false);
             }
-
         }
         LOG_info << "Received event storage changed: " << event->getNumber();
     }
+    else if (event->getType() == MegaEvent::EVENT_STORAGE_SUM_CHANGED)
+    {
+        sandboxCMD->receivedStorageSum = event->getNumber();
+    }
 }
 
 
@@ -223,6 +227,21 @@ void MegaCmdMegaListener::onRequestFinis
         LOG_debug << "Session closed";
         sandboxCMD->resetSandBox();
     }
+    else if (request->getType() == MegaRequest::TYPE_ACCOUNT_DETAILS)
+    {
+        if (e->getErrorCode() != MegaError::API_OK)
+        {
+            return;
+        }
+
+        bool storage = (request->getNumDetails() & 0x01) != 0;
+
+        if (storage)
+        {
+            unique_ptr<MegaAccountDetails> details(request->getMegaAccountDetails());
+            sandboxCMD->totalStorage = details->getStorageMax();
+        }
+    }
     else if (e && ( e->getErrorCode() == MegaError::API_ESID ))
     {
         LOG_err << "Session is no longer valid (it might have been invalidated from elsewhere) ";
@@ -902,7 +921,6 @@ MegaCmdGlobalTransferListener::MegaCmdGl
     this->megaApi = megaApi;
     this->sandboxCMD = sandboxCMD;
     this->listener = parent;
-    completedTransfersMutex.init(false);
 };
 
 void MegaCmdGlobalTransferListener::onTransferFinish(MegaApi* api, MegaTransfer *transfer, MegaError* error)
@@ -979,3 +997,4 @@ bool MegaCmdCatTransferListener::onTrans
 
     return true;
 }
+} //end namespace
--- a/src/listeners.h
+++ b/src/listeners.h
@@ -22,6 +22,7 @@
 #include "megacmdlogger.h"
 #include "megacmdsandbox.h"
 
+namespace megacmd {
 class MegaCmdListener : public mega::SynchronousRequestListener
 {
 private:
@@ -178,7 +179,7 @@ private:
     static const int MAXCOMPLETEDTRANSFERSBUFFER;
 
 public:
-    mega::MegaMutex completedTransfersMutex;
+    std::mutex completedTransfersMutex;
     std::deque<mega::MegaTransfer *> completedTransfers;
     std::map<mega::MegaHandle,std::string> completedPathsByHandle;
 public:
@@ -199,5 +200,5 @@ protected:
     mega::MegaTransferListener *listener;
 };
 
-
+} //end namespace
 #endif // LISTENERS_H
--- a/src/megacmdcommonutils.cpp
+++ b/src/megacmdcommonutils.cpp
@@ -34,8 +34,8 @@
 #include <limits.h>
 #include <iterator>
 
+namespace megacmd {
 using namespace std;
-
 #ifdef _WIN32
 
 //override << operators for wostream for string and const char *
@@ -116,6 +116,13 @@ void utf16ToUtf8(const wchar_t* utf16dat
         NULL, NULL));
 }
 
+std::string getutf8fromUtf16(const wchar_t *ws)
+{
+    string utf8s;
+    utf16ToUtf8(ws, wcslen(ws), &utf8s);
+    return utf8s;
+}
+
 #endif
 
 
@@ -135,7 +142,14 @@ bool canWrite(string path)
 
 bool isPublicLink(string link)
 {
-    if (( link.find("http") == 0 ) && ( link.find("#") != string::npos ))
+    //Old format:
+    //https://mega.nz/#!ph!key
+    //https://mega.nz/#F!ph!key
+
+    //new format:
+    //https://mega.nz/file/ph#key
+    //https://mega.nz/folder/ph#key
+    if (( link.find("http") == 0 ) && ( link.find("#") != string::npos || link.find("/file/") != string::npos || link.find("/folder/") != string::npos))
     {
         return true;
     }
@@ -151,6 +165,69 @@ bool isEncryptedLink(string link)
     return false;
 }
 
+string getPublicLinkHandle(const string &link)
+{
+    size_t posFolder = string::npos;
+    size_t posLastSep = link.rfind("?");
+    if (posLastSep == string::npos )
+    {
+        string rest = link;
+        int count = 0;
+        size_t posExc = rest.find_first_of("!");
+        while ( posExc != string::npos && (posExc +1) < rest.size())
+        {
+            count++;
+            if (count <= 3 )
+            {
+                posLastSep += posExc + 1;
+            }
+
+            rest = rest.substr(posExc + 1);
+            posExc = rest.find("!");
+        }
+
+        if (count != 3)
+        {
+            posLastSep = string::npos;
+        }
+    }
+
+    if (posLastSep == string::npos )
+    {
+        posFolder = link.find("/folder/");
+    }
+
+    if (posFolder != string::npos)
+    {
+        posLastSep = link.rfind("/file/");
+        if (posLastSep != string::npos)
+        {
+            posLastSep += strlen("/file/")-1;
+        }
+        else
+        {
+            posLastSep = link.rfind("/folder/");
+            if (posLastSep != string::npos && posFolder != posLastSep)
+            {
+                posLastSep += strlen("/folder/")-1;
+            }
+            else
+            {
+                return string();
+            }
+        }
+    }
+
+    if (( posLastSep == string::npos ) || !( posLastSep + 1 < link.length()))
+    {
+        return string();
+    }
+    else
+    {
+        return link.substr(posLastSep+1);
+    }
+}
+
 bool hasWildCards(string &what)
 {
     return what.find('*') != string::npos || what.find('?') != string::npos;
@@ -401,7 +478,15 @@ unsigned int getstringutf8size(const str
 #ifdef _WIN32
         else if ((c & 0xF0) == 0xE0) i+=2;
 #else
-        else if ((c & 0xF0) == 0xE0) {i+=2;q++;} //these gliphs may occupy 2 characters! Problem: not always. Let's assume the worse
+        else if ((c & 0xF0) == 0xE0)
+        {
+            if ((i+2)>ix || c != 0xE2 || (strncmp(&str.c_str()[i],"\u21f5",3)
+                    && strncmp(&str.c_str()[i],"\u21d3",3) && strncmp(&str.c_str()[i],"\u21d1",3) ) )
+            { //known 1 character gliphs
+                q++;
+            }
+            i+=2;
+        } //these gliphs may occupy 2 characters! Problem: not always. Let's assume the worse
 #endif
         else if ((c & 0xF8) == 0xF0) i+=3;
         else return 0;//invalid utf8
@@ -409,7 +494,7 @@ unsigned int getstringutf8size(const str
     return q;
 }
 
-string getFixLengthString(const string origin, unsigned int size, const char delim, bool alignedright)
+string getFixLengthString(const string &origin, unsigned int size, const char delim, bool alignedright)
 {
     string toret;
     size_t printableSize = getstringutf8size(origin);
@@ -469,6 +554,8 @@ void printCenteredContents(OUTSTREAMTYPE
     headfoot.append(width, '-');
     unsigned int msjsize = getstringutf8size(msj);
 
+    bool printfooter = false;
+
     if (msj.size())
     {
         string header;
@@ -484,8 +571,11 @@ void printCenteredContents(OUTSTREAMTYPE
                 msj = msj.substr(possenditle + 1);
             }
         }
-
-        os << (header.size()?header:headfoot) << endl;
+        if (header.size() || encapsulated)
+        {
+            os << (header.size()?header:headfoot) << endl;
+            printfooter = true;
+        }
     }
 
     size_t possepnewline = msj.find("\n");
@@ -534,7 +624,10 @@ void printCenteredContents(OUTSTREAMTYPE
             }
         }
     }
-    os << headfoot << endl;
+    if (printfooter)
+    {
+        os << headfoot << endl;
+    }
 }
 
 void printCenteredLine(string msj, unsigned int width, bool encapsulated)
@@ -860,6 +953,29 @@ bool isValidEmail(string email)
                     || (email.find("@") > email.find_last_of(".")));
 }
 
+#ifdef __linux__
+std::string getCurrentExecPath()
+{
+    std::string path = ".";
+    pid_t pid = getpid();
+    char buf[20] = {0};
+    sprintf(buf,"%d",pid);
+    std::string _link = "/proc/";
+    _link.append( buf );
+    _link.append( "/exe");
+    char proc[PATH_MAX];
+    int ch = readlink(_link.c_str(),proc,PATH_MAX);
+    if (ch != -1) {
+        proc[ch] = 0;
+        path = proc;
+        std::string::size_type t = path.find_last_of("/");
+        path = path.substr(0,t);
+    }
+
+    return path;
+}
+#endif
+
 string &ltrimProperty(string &s, const char &c)
 {
     size_t pos = s.find_first_not_of(c);
@@ -924,3 +1040,145 @@ string getPropertyFromFile(const char *c
 
     return string();
 }
+
+void ColumnDisplayer::endregistry()
+{
+    values.push_back(std::move(currentRegistry));
+    currentlength = 0;
+}
+
+void ColumnDisplayer::addHeader(const string &name, bool fixed, int minWidth)
+{
+    fields[name] = Field(name, fixed, minWidth);
+}
+
+void ColumnDisplayer::addValue(const string &name, const string &value, bool replace)
+{
+    int len = getstringutf8size(value);
+    if (!replace)
+    {
+        if (currentRegistry.size() && currentRegistry.find(name) != currentRegistry.end())
+        {
+            endregistry();
+        }
+    }
+
+    currentRegistry[name] = value;
+    currentlength += len;
+    if (fields.find(name) == fields.end())
+    {
+        addHeader(name, true);
+    }
+    if (find (fieldnames.begin(), fieldnames.end(), name) == fieldnames.end())
+    {
+        fieldnames.push_back(name);
+    }
+
+    fields[name].updateMaxValue(len);
+}
+
+void ColumnDisplayer::print(OUTSTREAMTYPE &os, int fullWidth, bool printHeader)
+{
+    if (currentRegistry.size())
+    {
+        endregistry();
+    }
+
+    int unfixedfieldscount = 0;
+    int leftWidth = fullWidth;
+    vector<Field *> unfixedfields;
+    for (auto &el : fields)
+    {
+        Field &f = el.second;
+        if (f.fixedSize)
+
+        {
+            if (f.fixedWidth)
+            {
+                f.dispWidth = f.fixedWidth;
+            }
+            else
+            {
+                f.dispWidth = max((int)getstringutf8size(f.name),f.maxValueLength);
+            }
+            leftWidth-=(f.dispWidth + 1);
+        }
+        else
+        {
+            unfixedfieldscount++;
+            unfixedfields.push_back(&f);
+        }
+    }
+
+    for (auto &f: unfixedfields)
+    {
+        f->dispWidth = max((int)getstringutf8size(f->name), min((leftWidth - unfixedfieldscount + 1)/(unfixedfieldscount), f->maxValueLength));
+        leftWidth-=(f->dispWidth + 1);
+        unfixedfieldscount--;
+    }
+
+    if (printHeader)
+    {
+        bool first = true;
+        for (auto el : fieldnames)
+        {
+            Field &f = fields[el];
+            if (!first)
+            {
+                os << " ";
+            }
+            first = false;
+            os << getFixLengthString(f.name, f.dispWidth);
+        }
+    }
+    os << std::endl;
+
+    for (auto &registry : values)
+    {
+        bool firstvalue = true;
+        for (auto &el : fieldnames)
+        {
+            Field &f = fields[el];
+            if (!firstvalue)
+            {
+                os << " ";
+            }
+            firstvalue = false;
+
+            if (registry.find(f.name) != registry.end())
+            {
+                os << getFixLengthString(registry[f.name], f.dispWidth);
+            }
+            else
+            {
+                os << getFixLengthString("", f.dispWidth);
+            }
+
+        }
+        os << std::endl;
+    }
+}
+
+Field::Field()
+{
+
+}
+
+Field::Field(string name, bool fixed, int minWidth) :name(name), fixedSize(fixed), fixedWidth(minWidth)
+{
+    if (fixed)
+    {
+        this->dispWidth = minWidth;
+    }
+
+}
+
+void Field::updateMaxValue(int newcandidate)
+{
+    if (newcandidate > this->maxValueLength)
+    {
+        this->maxValueLength = newcandidate;
+    }
+}
+
+} //end namespace
--- a/src/megacmdcommonutils.h
+++ b/src/megacmdcommonutils.h
@@ -28,10 +28,14 @@
 #include <sstream>
 #include <iostream>
 #include <iomanip>
+#include <mutex>
+
 
 using std::setw;
 using std::left;
 
+namespace megacmd {
+
 /* platform dependent */
 #ifdef _WIN32
 
@@ -47,6 +51,7 @@ std::ostringstream & operator<< ( std::o
 
 void stringtolocalw(const char* path, std::wstring* local);
 void localwtostring(const std::wstring* wide, std::string *multibyte);
+std::string getutf8fromUtf16(const wchar_t *ws);
 void utf16ToUtf8(const wchar_t* utf16data, int utf16size, std::string* utf8string);
 
 #else
@@ -60,6 +65,67 @@ void utf16ToUtf8(const wchar_t* utf16dat
 
 #define OUTSTREAM COUT
 
+
+/* commands */
+static std::vector<std::string> validGlobalParameters {"v", "help"};
+static std::vector<std::string> localremotefolderpatterncommands {"sync"};
+static std::vector<std::string> remotepatterncommands {"export", "attr"};
+static std::vector<std::string> remotefolderspatterncommands {"cd", "share"};
+
+static std::vector<std::string> multipleremotepatterncommands {"ls", "tree", "mkdir", "rm", "du", "find", "mv", "deleteversions", "cat", "mediainfo"
+#ifdef HAVE_LIBUV
+                                           , "webdav", "ftp"
+#endif
+                                          };
+
+static std::vector<std::string> remoteremotepatterncommands {"cp"};
+
+static std::vector<std::string> remotelocalpatterncommands {"get", "thumbnail", "preview"};
+
+static std::vector<std::string> localfolderpatterncommands {"lcd"};
+
+static std::vector<std::string> emailpatterncommands {"invite", "signup", "ipc", "users"};
+
+static std::vector<std::string> loginInValidCommands { "log", "debug", "speedlimit","help", "logout", "version", "quit",
+                            "clear", "https", "exit", "errorcode", "proxy"
+#if defined(_WIN32) && defined(NO_READLINE)
+                             , "autocomplete", "codepage"
+#elif defined(_WIN32)
+                             , "unicode"
+#endif
+#if defined(_WIN32) || defined(__APPLE__)
+                             , "update"
+#endif
+                           };
+
+static std::vector<std::string> allValidCommands { "login", "signup", "confirm", "session", "mount", "ls", "cd", "log", "debug", "pwd", "lcd", "lpwd", "import", "masterkey",
+                             "put", "get", "attr", "userattr", "mkdir", "rm", "du", "mv", "cp", "sync", "export", "share", "invite", "ipc", "df",
+                             "showpcr", "users", "speedlimit", "killsession", "whoami", "help", "passwd", "reload", "logout", "version", "quit",
+                             "thumbnail", "preview", "find", "completion", "clear", "https", "transfers", "exclude", "exit", "errorcode", "graphics",
+                             "cancel", "confirmcancel", "cat", "tree", "psa", "proxy"
+                             , "mediainfo"
+#ifdef HAVE_LIBUV
+                             , "webdav", "ftp"
+#endif
+#ifdef ENABLE_BACKUPS
+                             , "backup"
+#endif
+                             , "deleteversions"
+#if defined(_WIN32) && defined(NO_READLINE)
+                             , "autocomplete", "codepage"
+#elif defined(_WIN32)
+                             , "unicode"
+#else
+                             , "permissions"
+#endif
+#if defined(_WIN32) || defined(__APPLE__)
+                             , "update"
+#endif
+                           };
+
+
+static const int RESUME_SESSION_TIMEOUT = 10;
+
 /* Files and folders */
 
 //tests if a path is writable  //TODO: move to fsAccess
@@ -69,6 +135,8 @@ bool isPublicLink(std::string link);
 
 bool isEncryptedLink(std::string link);
 
+std::string getPublicLinkHandle(const std::string &link);
+
 bool hasWildCards(std::string &what);
 
 
@@ -96,7 +164,7 @@ int toInteger(std::string what, int fail
 
 std::string joinStrings(const std::vector<std::string>& vec, const char* delim = " ", bool quoted=true);
 
-std::string getFixLengthString(const std::string origin, unsigned int size, const char delimm=' ', bool alignedright = false);
+std::string getFixLengthString(const std::string &origin, unsigned int size, const char delimm=' ', bool alignedright = false);
 
 std::string getRightAlignedString(const std::string origin, unsigned int minsize);
 
@@ -153,6 +221,9 @@ void sleepMilliSeconds(long microseconds
 
 bool isValidEmail(std::string email);
 
+#ifdef __linux__
+std::string getCurrentExecPath();
+#endif
 
 /* Properties */
 std::string &ltrimProperty(std::string &s, const char &c);
@@ -169,7 +240,42 @@ T getValueFromFile(const char *configFil
     std::istringstream is(propValue);
     is >> i;
     return i;
-
 }
 
+class Field
+{
+public:
+    Field();
+    Field(std::string name, bool fixed = false, int fixedWidth = 0);
+
+public:
+    std::string name;
+    int fixedWidth;
+    bool fixedSize;
+    int dispWidth = 0;
+    int maxValueLength = 0;
+
+    void updateMaxValue(int newcandidate);
+};
+
+class ColumnDisplayer
+{
+public:
+    void print(OUTSTREAMTYPE &os, int fullWidth, bool printHeader=true);
+    void addHeader(const std::string &name, bool fixed = true, int minWidth = 0);
+    void addValue(const std::string &name, const std::string & value, bool replace = false);
+    void endregistry();
+
+private:
+    std::map<std::string, Field> fields;
+    std::vector<std::string> fieldnames;
+    std::vector<std::map<std::string, std::string>> values;
+    std::vector<int> lengths;
+
+    std::map<std::string, std::string> currentRegistry;
+    int currentlength = 0;
+
+};
+
+}//end namespace
 #endif // MEGACMDCOMMONUTILS_H
--- a/src/megacmd.cpp
+++ b/src/megacmd.cpp
@@ -34,7 +34,12 @@
 
 #include <iomanip>
 #include <string>
+#include <deque>
+#include <atomic>
 
+#ifdef __linux__
+#include <condition_variable>
+#endif
 #ifndef _WIN32
 #include "signal.h"
 #include <sys/wait.h>
@@ -60,7 +65,6 @@
 #  endif
 #endif
 
-typedef char *completionfunction_t PARAMS((const char *, int));
 
 #define SSTR( x ) static_cast< const std::ostringstream & >( \
         ( std::ostringstream() << std::dec << x ) ).str()
@@ -90,7 +94,10 @@ typedef char *completionfunction_t PARAM
 #endif
 
 using namespace mega;
+
+namespace megacmd {
 using namespace std;
+typedef char *completionfunction_t PARAMS((const char *, int));
 
 MegaCmdExecuter *cmdexecuter;
 MegaCmdSandbox *sandboxCMD;
@@ -103,15 +110,19 @@ MegaApi *api;
 std::queue<MegaApi *> apiFolders;
 std::vector<MegaApi *> occupiedapiFolders;
 MegaSemaphore semaphoreapiFolders;
-MegaMutex mutexapiFolders;
+std::mutex mutexapiFolders;
 
 MegaCMDLogger *loggerCMD;
 
-MegaMutex mutexEndedPetitionThreads;
+std::mutex mutexEndedPetitionThreads;
 std::vector<MegaThread *> petitionThreads;
 std::vector<MegaThread *> endedPetitionThreads;
 MegaThread *threadRetryConnections;
 
+std::deque<std::string> greetingsFirstClientMsgs; // to be given on first client to register as state listener
+std::deque<std::string> greetingsAllClientMsgs; // to be given on all clients when registering as state listener
+std::mutex greetingsmsgsMutex;
+
 //Comunications Manager
 ComunicationsManager * cm;
 
@@ -120,63 +131,7 @@ MegaCmdGlobalListener* megaCmdGlobalList
 
 MegaCmdMegaListener* megaCmdMegaListener;
 
-bool loginInAtStartup = false;
-
-string validGlobalParameters[] = {"v", "help"};
-
-string alocalremotefolderpatterncommands [] = {"sync"};
-vector<string> localremotefolderpatterncommands(alocalremotefolderpatterncommands, alocalremotefolderpatterncommands + sizeof alocalremotefolderpatterncommands / sizeof alocalremotefolderpatterncommands[0]);
-
-string aremotepatterncommands[] = {"export", "attr"};
-vector<string> remotepatterncommands(aremotepatterncommands, aremotepatterncommands + sizeof aremotepatterncommands / sizeof aremotepatterncommands[0]);
-
-string aremotefolderspatterncommands[] = {"cd", "share"};
-vector<string> remotefolderspatterncommands(aremotefolderspatterncommands, aremotefolderspatterncommands + sizeof aremotefolderspatterncommands / sizeof aremotefolderspatterncommands[0]);
-
-string amultipleremotepatterncommands[] = {"ls", "tree", "mkdir", "rm", "du", "find", "mv", "deleteversions", "cat", "mediainfo"
-#ifdef HAVE_LIBUV
-                                           , "webdav", "ftp"
-#endif
-                                          };
-vector<string> multipleremotepatterncommands(amultipleremotepatterncommands, amultipleremotepatterncommands + sizeof amultipleremotepatterncommands / sizeof amultipleremotepatterncommands[0]);
-
-string aremoteremotepatterncommands[] = {"cp"};
-vector<string> remoteremotepatterncommands(aremoteremotepatterncommands, aremoteremotepatterncommands + sizeof aremoteremotepatterncommands / sizeof aremoteremotepatterncommands[0]);
-
-string aremotelocalpatterncommands[] = {"get", "thumbnail", "preview"};
-vector<string> remotelocalpatterncommands(aremotelocalpatterncommands, aremotelocalpatterncommands + sizeof aremotelocalpatterncommands / sizeof aremotelocalpatterncommands[0]);
-
-string alocalfolderpatterncommands [] = {"lcd"};
-vector<string> localfolderpatterncommands(alocalfolderpatterncommands, alocalfolderpatterncommands + sizeof alocalfolderpatterncommands / sizeof alocalfolderpatterncommands[0]);
-
-string aemailpatterncommands [] = {"invite", "signup", "ipc", "users"};
-vector<string> emailpatterncommands(aemailpatterncommands, aemailpatterncommands + sizeof aemailpatterncommands / sizeof aemailpatterncommands[0]);
-
-string avalidCommands [] = { "login", "signup", "confirm", "session", "mount", "ls", "cd", "log", "debug", "pwd", "lcd", "lpwd", "import", "masterkey",
-                             "put", "get", "attr", "userattr", "mkdir", "rm", "du", "mv", "cp", "sync", "export", "share", "invite", "ipc", "df",
-                             "showpcr", "users", "speedlimit", "killsession", "whoami", "help", "passwd", "reload", "logout", "version", "quit",
-                             "thumbnail", "preview", "find", "completion", "clear", "https", "transfers", "exclude", "exit", "errorcode", "graphics",
-                             "cancel", "confirmcancel", "cat", "tree", "psa"
-                             , "mediainfo"
-#ifdef HAVE_LIBUV
-                             , "webdav", "ftp"
-#endif
-#ifdef ENABLE_BACKUPS
-                             , "backup"
-#endif
-                             , "deleteversions"
-#if defined(_WIN32) && defined(NO_READLINE)
-                             , "autocomplete", "codepage"
-#elif defined(_WIN32)
-                             , "unicode"
-#else
-                             , "permissions"
-#endif
-#if defined(_WIN32) || defined(__APPLE__)
-                             , "update"
-#endif
-                           };
-vector<string> validCommands(avalidCommands, avalidCommands + sizeof avalidCommands / sizeof avalidCommands[0]);
+vector<string> validCommands = allValidCommands;
 
 // password change-related state information
 string oldpasswd;
@@ -191,10 +146,15 @@ string dynamicprompt = "MEGA CMD> ";
 
 static prompttype prompt = COMMAND;
 
+static std::atomic_bool loginInAtStartup(false);
+static std::atomic<::mega::m_time_t> timeOfLoginInAtStartup(0);
+::mega::m_time_t timeLoginStarted();
+
+
 // local console
 Console* console;
 
-MegaMutex mutexHistory;
+std::mutex mutexHistory;
 
 map<unsigned long long, string> threadline;
 
@@ -203,6 +163,52 @@ int mcmdMainArgc;
 
 void printWelcomeMsg();
 
+void delete_finished_threads();
+
+void appendGreetingStatusFirstListener(const std::string &msj)
+{
+    std::lock_guard<std::mutex> g(greetingsmsgsMutex);
+    greetingsFirstClientMsgs.push_front(msj);
+}
+
+void removeGreetingStatusFirstListener(const std::string &msj)
+{
+    std::lock_guard<std::mutex> g(greetingsmsgsMutex);
+    for(auto it = greetingsFirstClientMsgs.begin(); it != greetingsFirstClientMsgs.end();)
+    {
+       if (*it == msj)
+       {
+           it = greetingsFirstClientMsgs.erase(it);
+       }
+       else
+       {
+           ++it;
+       }
+    }
+}
+
+void appendGreetingStatusAllListener(const std::string &msj)
+{
+    std::lock_guard<std::mutex> g(greetingsmsgsMutex);
+    greetingsAllClientMsgs.push_front(msj);
+}
+
+void removeGreetingStatusAllListener(const std::string &msj)
+{
+    std::lock_guard<std::mutex> g(greetingsmsgsMutex);
+    for(auto it = greetingsAllClientMsgs.begin(); it != greetingsAllClientMsgs.end();)
+    {
+       if (*it == msj)
+       {
+           it = greetingsAllClientMsgs.erase(it);
+       }
+       else
+       {
+           ++it;
+       }
+    }
+}
+
 string getCurrentThreadLine()
 {
     uint64_t currentThread = MegaThread::currentThreadId();
@@ -229,11 +235,6 @@ void setCurrentThreadLine(const vector<s
 void sigint_handler(int signum)
 {
     LOG_verbose << "Received signal: " << signum;
-    if (loginInAtStartup)
-    {
-        exit(-2);
-    }
-
     LOG_debug << "Exiting due to SIGINT";
 
     stopcheckingforUpdaters = true;
@@ -294,6 +295,11 @@ void changeprompt(const char *newprompt)
     cm->informStateListeners(s);
 }
 
+void informStateListeners(string s)
+{
+    cm->informStateListeners(s);
+}
+
 void informStateListener(string message, int clientID)
 {
     string s;
@@ -301,19 +307,23 @@ void informStateListener(string message,
     {
         s += "message:";
         s+=message;
+        cm->informStateListenerByClientId(s, clientID);
     }
-    cm->informStateListenerByClientId(s, clientID);
 }
 
-void broadcastMessage(string message)
+void broadcastMessage(string message, bool keepIfNoListeners)
 {
     string s;
     if (message.size())
     {
         s += "message:";
         s+=message;
+
+        if (!cm->informStateListeners(s) && keepIfNoListeners)
+        {
+            appendGreetingStatusFirstListener(s);
+        }
     }
-    cm->informStateListeners(s);
 }
 
 void informTransferUpdate(MegaTransfer *transfer, int clientID)
@@ -348,6 +358,10 @@ void insertValidParamsPerCommand(set<str
     {
         validOptValues = validParams;
     }
+
+    validOptValues->insert("client-width");
+
+
     if ("ls" == thecommand)
     {
         validParams->insert("R");
@@ -653,6 +667,13 @@ void insertValidParamsPerCommand(set<str
         validOptValues->insert("limit");
         validOptValues->insert("path-display-size");
     }
+    else if ("proxy" == thecommand)
+    {
+        validParams->insert("auto");
+        validParams->insert("none");
+        validOptValues->insert("username");
+        validOptValues->insert("password");
+    }
     else if ("exit" == thecommand || "quit" == thecommand)
     {
         validParams->insert("only-shell");
@@ -745,9 +766,9 @@ char* local_completion(const char* text,
 
 void addGlobalFlags(set<string> *setvalidparams)
 {
-    for (size_t i = 0; i < sizeof( validGlobalParameters ) / sizeof( *validGlobalParameters ); i++)
+    for (auto &v :  validGlobalParameters)
     {
-        setvalidparams->insert(validGlobalParameters[i]);
+        setvalidparams->insert(v);
     }
 }
 
@@ -1245,7 +1266,7 @@ completionfunction_t *getCompletionFunct
     return empty_completion;
 }
 
-string getListOfCompletionValues(vector<string> words, char separator = ' ', const char * separators = " ;!`\"'\\()[]{}<>", bool suppressflag = true)
+string getListOfCompletionValues(vector<string> words, char separator = ' ', const char * separators = " :;!`\"'\\()[]{}<>", bool suppressflag = true)
 {
     string completionValues;
     completionfunction_t * compfunction = getCompletionFunction(words);
@@ -1894,7 +1915,10 @@ string getHelpStr(const char *command)
     }
     else if (!strcmp(command, "mount"))
     {
-        os << "Lists all the main nodes" << endl;
+        os << "Lists all the root nodes" << endl;
+        os << endl;
+        os << "This includes the root node in your cloud drive, Inbox, Rubbish Bin " << endl;
+        os << "and all the in-shares (nodes shares to you from other users)" << endl;
     }
 #if defined(_WIN32) && !defined(NO_READLINE)
     else if (!strcmp(command, "unicode"))
@@ -2054,7 +2078,8 @@ string getHelpStr(const char *command)
         os << endl;
         os << "Notice that the dstremotepath can only be omitted when only one local path is provided. " << endl;
         os << " In such case, the current remote working dir will be the destination for the upload." << endl;
-        os << " Mind that using wildcards for local paths will result in multiple paths." << endl;
+        os << " Mind that using wildcards for local paths in non-interactive mode in a supportive console (e.g. bash)," << endl;
+        os << " could result in multiple paths being passed to MEGAcmd." << endl;
     }
     else if (!strcmp(command, "get"))
     {
@@ -2647,16 +2672,22 @@ string getHelpStr(const char *command)
         os << endl;
         os << "TYPE legend correspondence:" << endl;
 #ifdef _WIN32
-        os << "  D = \t" << "Download transfer" << endl;
-        os << "  U = \t" << "Upload transfer" << endl;
-        os << "  S = \t" << "Sync transfer. The transfer is done in the context of a synchronization" << endl;
-        os << "  B = \t" << "Backup transfer. The transfer is done in the context of a backup" << endl;
+
+        const string cD = getutf8fromUtf16(L"\u25bc");
+        const string cU = getutf8fromUtf16(L"\u25b2");
+        const string cS = getutf8fromUtf16(L"\u21a8");
+        const string cB = getutf8fromUtf16(L"\u2191");
 #else
-        os << "  \u21d3 = \t" << "Download transfer" << endl;
-        os << "  \u21d1 = \t" << "Upload transfer" << endl;
-        os << "  \u21f5 = \t" << "Sync transfer. The transfer is done in the context of a synchronization" << endl;
-        os << "  \u23eb = \t" << "Backup transfer. The transfer is done in the context of a backup" << endl;
-#endif
+        const string cD = "\u21d3";
+        const string cU = "\u21d1";
+        const string cS = "\u21f5";
+        const string cB = "\u23eb";
+#endif
+        os << "  " << cD <<" = \t" << "Download transfer" << endl;
+        os << "  " << cU <<" = \t" << "Upload transfer" << endl;
+        os << "  " << cS <<" = \t" << "Sync transfer. The transfer is done in the context of a synchronization" << endl;
+        os << "  " << cB <<" = \t" << "Backup transfer. The transfer is done in the context of a backup" << endl;
+
     }
 #if defined(_WIN32) && defined(NO_READLINE)
     else if (!strcmp(command, "autocomplete"))
@@ -2826,7 +2857,14 @@ void executecommand(char* ptr)
     if (!validCommand(thecommand))   //unknown command
     {
         setCurrentOutCode(MCMD_EARGS);
-        LOG_err << "Command not found: " << thecommand;
+        if (loginInAtStartup)
+        {
+            LOG_err << "Command not valid while login in: " << thecommand;
+        }
+        else
+        {
+            LOG_err << "Command not found: " << thecommand;
+        }
         return;
     }
 
@@ -3158,22 +3196,40 @@ bool restartServer()
     if ( childid ) //parent
     {
         char **argv = new char*[mcmdMainArgc+3];
-        int i = 0;
+        int i = 0, j = 0;
+
+#ifdef __linux__
+        string executable = mcmdMainArgv[0];
+        if (executable.find("/") != 0)
+        {
+            executable.insert(0, getCurrentExecPath()+"/");
+        }
+        argv[0]=(char *)executable.c_str();
+        i++;
+        j++;
+#endif
+
         for (;i < mcmdMainArgc; i++)
         {
-            argv[i]=mcmdMainArgv[i];
+            if ( (i+1) < mcmdMainArgc && !strcmp(mcmdMainArgv[i],"--wait-for"))
+            {
+                i+=2;
+            }
+            else
+            {
+                argv[j++]=mcmdMainArgv[i];
+            }
         }
 
-        argv[i++]="--wait-for";
-        argv[i++]=(char*)SSTR(childid).c_str();
-        argv[i++]=NULL;
-        LOG_debug << "Restarting the server : <" << argv[0] << ">";
+        argv[j++]="--wait-for";
+        argv[j++]=(char*)SSTR(childid).c_str();
+        argv[j++]=NULL;
 
+        LOG_debug << "Restarting the server : <" << argv[0] << ">";
         execv(argv[0],argv);
     }
 #endif
 
-
     LOG_debug << "Server restarted, indicating the shell to restart also";
     setCurrentOutCode(MCMD_REQRESTART);
 
@@ -3183,6 +3239,33 @@ bool restartServer()
     return true;
 }
 
+bool isBareCommand(const char *l, const string &command)
+{
+    string what(l);
+    string xcommand = "X" + command;
+    if (what == command || what == xcommand)
+    {
+        return true;
+    }
+    if (what.find(command+" ") != 0 && what.find(xcommand+" ") != 0 )
+    {
+        return false;
+    }
+
+   vector<string> words = getlistOfWords((char *)l, !getCurrentThreadIsCmdShell());
+   for (int i = 1; i<words.size(); i++)
+   {
+       if (words[i].empty()) continue;
+       if (words[i] == "--help") return false;
+       if (words[i].find("--client-width") == 0) continue;
+       if (words[i].find("--clientID") == 0) continue;
+
+       return false;
+   }
+
+   return true;
+}
+
 static bool process_line(char* l)
 {
     switch (prompt)
@@ -3277,14 +3360,27 @@ static bool process_line(char* l)
 
         case COMMAND:
         {
-            if (!l || !strcmp(l, "q") || !strcmp(l, "quit") || !strcmp(l, "exit") || !strcmp(l, "exit ") || !strcmp(l, "quit "))
+            if (!l || !strcmp(l, "q") || !strcmp(l, "quit") || !strcmp(l, "exit")
+                || ( (!strncmp(l, "quit ", strlen("quit ")) || !strncmp(l, "exit ", strlen("exit ")) ) && !strstr(l,"--help") )  )
             {
                 //                store_line(NULL);
+
+                if (strstr(l,"--wait-for-ongoing-petitions"))
+                {
+                    int attempts=20; //give a while for ongoing petitions to end before killing the server
+                    delete_finished_threads();
+
+                    while(petitionThreads.size() > 1 && attempts--)
+                    {
+                        LOG_debug << "giving a little longer for ongoing petitions: " << petitionThreads.size();
+                        sleepSeconds(20-attempts);
+                        delete_finished_threads();
+                    }
+                }
+
                 return true; // exit
             }
-
-            else  if (!strncmp(l,"sendack",strlen("sendack")) ||
-                      !strncmp(l,"Xsendack",strlen("Xsendack")))
+            else if (isBareCommand(l, "sendack"))
             {
                 string sack="ack";
                 cm->informStateListeners(sack);
@@ -3292,7 +3388,7 @@ static bool process_line(char* l)
             }
 
 #if defined(_WIN32) || defined(__APPLE__)
-            else if (!strcmp(l, "update") || !strcmp(l, "update ")) //if extra args are received, it'll be processed by executer
+            else if (isBareCommand(l, "update")) //if extra args are received, it'll be processed by executer
             {
                 string confirmationQuery("This might require restarting MEGAcmd. Are you sure to continue");
                 confirmationQuery+="? (Yes/No): ";
@@ -3316,7 +3412,7 @@ static bool process_line(char* l)
                 {
                     OUTSTREAM << " " << endl;
 
-                    int attempts=20; //give a while for ingoin petitions to end before killing the server
+                    int attempts=20; //give a while for ongoing petitions to end before killing the server
                     while(petitionThreads.size() > 1 && attempts--)
                     {
                         sleepSeconds(20-attempts);
@@ -3349,19 +3445,22 @@ void * doProcessLine(void *pointer)
     LoggedStreamPartialOutputs ls(cm, inf);
     setCurrentThreadOutStream(&ls);
 
+    bool isInteractive = false;
+
     if (inf->getLine() && *(inf->getLine())=='X')
     {
         setCurrentThreadIsCmdShell(true);
         char * aux = inf->line;
         inf->line=strdup(inf->line+1);
         free(aux);
+        isInteractive = true;
     }
     else
     {
         setCurrentThreadIsCmdShell(false);
     }
 
-    LOG_verbose << " Processing " << *inf << " in thread: " << MegaThread::currentThreadId() << " " << cm->get_petition_details(inf);
+    LOG_verbose << " Processing " << inf->line << " in thread: " << MegaThread::currentThreadId() << " " << cm->get_petition_details(inf);
 
     doExit = process_line(inf->getLine());
 
@@ -3371,10 +3470,18 @@ void * doProcessLine(void *pointer)
         LOG_verbose << " Exit registered upon process_line: " ;
     }
 
-    LOG_verbose << " Procesed " << *inf << " in thread: " << MegaThread::currentThreadId() << " " << cm->get_petition_details(inf);
+    LOG_verbose << " Procesed " << inf->line << " in thread: " << MegaThread::currentThreadId() << " " << cm->get_petition_details(inf);
 
     MegaThread * petitionThread = inf->getPetitionThread();
-    cm->returnAndClosePetition(inf, &s, getCurrentOutCode());
+
+    if (inf->clientID == -3) //self client: no actual client
+    {
+        delete inf;//simply delete the pointer
+    }
+    else
+    {
+        cm->returnAndClosePetition(inf, &s, getCurrentOutCode());
+    }
 
     semaphoreClients.release();
 
@@ -3448,9 +3555,38 @@ void delete_finished_threads()
     mutexEndedPetitionThreads.unlock();
 }
 
+void processCommandInPetitionQueues(CmdPetition *inf);
+void processCommandLinePetitionQueues(std::string what);
 
+bool waitForRestartSignal = false;
+#ifdef __linux__
+std::mutex mtxcondvar;
+std::condition_variable condVarRestart;
+bool condVarRestartBool = false;
+string appToWaitForSignal;
 
-void finalize()
+void LinuxSignalHandler(int signum)
+{
+    if (signum == SIGUSR2)
+    {
+        std::unique_lock<std::mutex> lock(mtxcondvar);
+        condVarRestart.notify_one();
+        condVarRestartBool = true;
+    }
+    else if (signum == SIGUSR1)
+    {
+        if (!waitForRestartSignal)
+        {
+            waitForRestartSignal = true;
+            LOG_debug << "Preparing MEGAcmd to restart: ";
+            stopcheckingforUpdaters = true;
+            doExit = true;
+        }
+    }
+}
+#endif
+
+void finalize(bool waitForRestartSignal)
 {
     static bool alreadyfinalized = false;
     if (alreadyfinalized)
@@ -3458,7 +3594,6 @@ void finalize()
     alreadyfinalized = true;
     LOG_info << "closing application ...";
     delete_finished_threads();
-    delete cm;
     if (!consoleFailed)
     {
         delete console;
@@ -3488,12 +3623,32 @@ void finalize()
     delete megaCmdGlobalListener;
     delete cmdexecuter;
 
+#ifdef __linux__
+    if (waitForRestartSignal)
+    {
+        LOG_debug << "Waiting for signal to restart MEGAcmd ... ";
+        std::unique_lock<std::mutex> lock(mtxcondvar);
+        if (condVarRestartBool || condVarRestart.wait_for(lock, std::chrono::minutes(30)) == std::cv_status::no_timeout )
+        {
+            restartServer();
+        }
+        else
+        {
+            LOG_err << "Former server still alive after waiting. Not restarted.";
+        }
+    }
+#endif
+    delete cm; //this needs to go after restartServer();
     LOG_debug << "resources have been cleaned ...";
     delete loggerCMD;
     ConfigurationManager::unlockExecution();
     ConfigurationManager::unloadConfiguration();
 
 }
+void finalize()
+{
+    finalize(false);
+}
 
 int currentclientID = 1;
 
@@ -3621,6 +3776,30 @@ void* checkForUpdates(void *param)
     return NULL;
 }
 
+void processCommandInPetitionQueues(CmdPetition *inf)
+{
+    semaphoreClients.wait();
+
+    //append new one
+    MegaThread * petitionThread = new MegaThread();
+
+    petitionThreads.push_back(petitionThread);
+    inf->setPetitionThread(petitionThread);
+
+    LOG_verbose << "starting processing: <" << inf->line << ">";
+
+    petitionThread->start(doProcessLine, (void*)inf);
+}
+
+void processCommandLinePetitionQueues(std::string what)
+{
+    CmdPetition *inf = new CmdPetition();
+    inf->line = strdup(what.c_str());
+    inf->clientDisconnected = true; //There's no actual client
+    inf->clientID = -3;
+    processCommandInPetitionQueues(inf);
+}
+
 // main loop
 void megacmd()
 {
@@ -3648,7 +3827,7 @@ void megacmd()
 
             CmdPetition *inf = cm->getPetition();
 
-            LOG_verbose << "petition registered: " << *inf;
+            LOG_verbose << "petition registered: " << inf->line;
 
             delete_finished_threads();
 
@@ -3670,7 +3849,6 @@ void megacmd()
                 s+=(char)0x1F;
                 inf->clientID = currentclientID;
                 currentclientID++;
-
                 cm->informStateListener(inf,s);
 
 #if defined(_WIN32) || defined(__APPLE__)
@@ -3788,6 +3966,37 @@ void megacmd()
                     s+=(char)0x1F;
                 }
 
+
+                // if server resuming session, lets give him a very litle while before sending greeting message to the early clients
+                // (to aovid "Resuming session..." being printed fast resumed session)
+                while (getloginInAtStartup() && ((m_time(nullptr) - timeLoginStarted() < RESUME_SESSION_TIMEOUT * 0.3)))
+                {
+                    sleepMilliSeconds(300);
+                }
+
+                {
+                    std::lock_guard<std::mutex> g(greetingsmsgsMutex);
+
+                    while(greetingsFirstClientMsgs.size())
+                    {
+                        cm->informStateListener(inf,greetingsFirstClientMsgs.front().append(1, (char)0x1F));
+                        greetingsFirstClientMsgs.pop_front();
+                    }
+
+                    for (auto m: greetingsAllClientMsgs)
+                    {
+                        cm->informStateListener(inf,m.append(1, (char)0x1F));
+                    }
+                }
+
+                // if server resuming session, lets give him a litle while before returning a prompt to the early clients
+                // This will block the server from responging any commands in the meantime, but that assumable, it will only happen
+                // the first time the server is initiated.
+                while (getloginInAtStartup() && ((m_time(nullptr) - timeLoginStarted() < RESUME_SESSION_TIMEOUT * 0.7)))
+                {
+                    sleepMilliSeconds(300);
+                }
+
                 // communicate status info
                 s+= "prompt:";
                 s+=dynamicprompt;
@@ -3799,18 +4008,7 @@ void megacmd()
             }
             else
             { // normal petition
-
-                semaphoreClients.wait();
-
-                //append new one
-                MegaThread * petitionThread = new MegaThread();
-
-                petitionThreads.push_back(petitionThread);
-                inf->setPetitionThread(petitionThread);
-
-                LOG_verbose << "starting processing: <" << *inf << ">";
-
-                petitionThread->start(doProcessLine, (void*)inf);
+                processCommandInPetitionQueues(inf);
             }
         }
     }
@@ -4266,6 +4464,30 @@ bool registerUpdater()
 #endif
 }
 
+bool getloginInAtStartup()
+{
+    return loginInAtStartup;
+}
+
+::mega::m_time_t timeLoginStarted()
+{
+    return timeOfLoginInAtStartup;
+}
+
+void setloginInAtStartup(bool value)
+{
+    loginInAtStartup = value;
+    if (value)
+    {
+        validCommands = loginInValidCommands;
+        timeOfLoginInAtStartup = m_time(NULL);
+    }
+    else
+    {
+        validCommands = allValidCommands;
+    }
+}
+
 #ifdef _WIN32
 void uninstall()
 {
@@ -4311,10 +4533,29 @@ void uninstall()
 
 #endif
 
+} //end namespace
 
+using namespace megacmd;
 
 int main(int argc, char* argv[])
 {
+#ifdef __linux__
+    // Ensure interesting signals are unblocked.
+    sigset_t signalstounblock;
+    sigemptyset (&signalstounblock);
+    sigaddset(&signalstounblock, SIGUSR1);
+    sigaddset(&signalstounblock, SIGUSR2);
+    sigprocmask(SIG_UNBLOCK, &signalstounblock, NULL);
+
+    if (signal(SIGUSR1, LinuxSignalHandler)) //TODO: do this after startup?
+    {
+        cerr << " Failed to register signal SIGUSR1 " << endl;
+    }
+    if (signal(SIGUSR2, LinuxSignalHandler))
+    {
+        LOG_debug << " Failed to register signal SIGUSR2 ";
+    }
+#endif
     string localecode = getLocaleCode();
 #ifdef _WIN32
     // Set Environment's default locale
@@ -4329,7 +4570,9 @@ int main(int argc, char* argv[])
 
     NullBuffer null_buffer;
     std::ostream null_stream(&null_buffer);
+#ifndef ENABLE_LOG_PERFORMANCE
     SimpleLogger::setAllOutputs(&null_stream);
+#endif
     SimpleLogger::setLogLevel(logMax); // do not filter anything here, log level checking is done by loggerCMD
 
     loggerCMD = new MegaCMDLogger();
@@ -4384,9 +4627,9 @@ int main(int argc, char* argv[])
 
         pid_t processId = atoi(shandletowait.c_str());
 
-        cout << "Waiting for former server to end... " << endl;
         while (is_pid_running(processId))
         {
+            cerr << "Waiting for former server to end:  " << processId << endl;
             sleep(1);
         }
 #endif
@@ -4411,10 +4654,6 @@ int main(int argc, char* argv[])
         loggerCMD->setCmdLoggerLevel(MegaApi::LOG_LEVEL_MAX);
     }
 
-    mutexHistory.init(false);
-
-    mutexEndedPetitionThreads.init(false);
-
     ConfigurationManager::loadConfiguration(( argc > 1 ) && debug);
     if (!ConfigurationManager::lockExecution() && !skiplockcheck)
     {
@@ -4424,12 +4663,12 @@ int main(int argc, char* argv[])
     }
 
     char userAgent[40];
-    sprintf(userAgent, "MEGAcmd" MEGACMD_STRINGIZE(MEGACMD_USERAGENT_SUFFIX) "/%d.%d.%d.0", MEGACMD_MAJOR_VERSION,MEGACMD_MINOR_VERSION,MEGACMD_MICRO_VERSION);
+    sprintf(userAgent, "MEGAcmd" MEGACMD_STRINGIZE(MEGACMD_USERAGENT_SUFFIX) "/%d.%d.%d.%d", MEGACMD_MAJOR_VERSION,MEGACMD_MINOR_VERSION,MEGACMD_MICRO_VERSION,MEGACMD_BUILD_ID);
 
     MegaApi::addLoggerObject(loggerCMD);
     MegaApi::setLogLevel(MegaApi::LOG_LEVEL_MAX);
 
-    LOG_debug << "MEGAcmd version: " << MEGACMD_MAJOR_VERSION << "." << MEGACMD_MINOR_VERSION << "." << MEGACMD_MICRO_VERSION << ": code " << MEGACMD_CODE_VERSION;
+    LOG_debug << "MEGAcmd version: " << MEGACMD_MAJOR_VERSION << "." << MEGACMD_MINOR_VERSION << "." << MEGACMD_MICRO_VERSION << "." << MEGACMD_BUILD_ID << ": code " << MEGACMD_CODE_VERSION;
 
 #if defined(__MACH__) && defined(ENABLE_SYNC)
     int fd = -1;
@@ -4476,8 +4715,6 @@ int main(int argc, char* argv[])
         semaphoreClients.release();
     }
 
-    mutexapiFolders.init(false);
-
     LOG_debug << "Language set to: " << localecode;
 
     sandboxCMD = new MegaCmdSandbox();
@@ -4542,17 +4779,36 @@ int main(int argc, char* argv[])
 
     printWelcomeMsg();
 
+
+    int configuredProxyType = ConfigurationManager::getConfigurationValue("proxy_type", -1);
+    auto configuredProxyUrl = ConfigurationManager::getConfigurationSValue("proxy_url");
+
+    auto configuredProxyUsername = ConfigurationManager::getConfigurationSValue("proxy_username");
+    auto configuredProxyPassword = ConfigurationManager::getConfigurationSValue("proxy_password");
+    if (configuredProxyType != -1 && configuredProxyType != MegaProxy::PROXY_AUTO) //AUTO is default, no need to set
+    {
+        std::string command("proxy ");
+        command.append(configuredProxyUrl);
+        if (configuredProxyUsername.size())
+        {
+            command.append(" --username=").append(configuredProxyUsername);
+            if (configuredProxyPassword.size())
+            {
+                command.append(" --password=").append(configuredProxyPassword);
+            }
+        }
+        processCommandLinePetitionQueues(command);
+    }
     if (!ConfigurationManager::session.empty())
     {
         loginInAtStartup = true;
         stringstream logLine;
         logLine << "login " << ConfigurationManager::session;
         LOG_debug << "Executing ... " << logLine.str().substr(0,9) << "...";
-        process_line((char*)logLine.str().c_str());
-        loginInAtStartup = false;
+        processCommandLinePetitionQueues(logLine.str());
     }
 
-    megacmd();
-    finalize();
+    megacmd::megacmd();
+    finalize(waitForRestartSignal);
 }
 
--- a/src/megacmdexecuter.cpp
+++ b/src/megacmdexecuter.cpp
@@ -39,7 +39,7 @@
     #include <filesystem>
     namespace fs = std::filesystem;
     #define MEGACMDEXECUTER_FILESYSTEM
-#elif !defined(__MINGW32__) && !defined(__ANDROID__) && ( (__cplusplus >= 201100L) || (defined(_MSC_VER) && _MSC_VER >= 1600) )
+#elif !defined(__MINGW32__) && !defined(__ANDROID__) && (!defined(__GNUC__) || (__GNUC__*100+__GNUC_MINOR__) >= 503)
 #define MEGACMDEXECUTER_FILESYSTEM
 #ifdef WIN32
     #include <filesystem>
@@ -52,6 +52,8 @@
 
 
 using namespace mega;
+
+namespace megacmd {
 using namespace std;
 
 static const char* rootnodenames[] = { "ROOT", "INBOX", "RUBBISH" };
@@ -60,6 +62,26 @@ static const char* rootnodepaths[] = { "
 #define SSTR( x ) static_cast< const std::ostringstream & >( \
         ( std::ostringstream() << std::dec << x ) ).str()
 
+
+#ifdef HAVE_GLOB_H
+std::vector<std::string> resolvewildcard(const std::string& pattern) {
+
+    vector<std::string> filenames;
+    glob_t glob_result;
+    memset(&glob_result, 0, sizeof(glob_result));
+
+    if (!glob(pattern.c_str(), GLOB_TILDE, NULL, &glob_result))
+    {
+        for(size_t i = 0; i < glob_result.gl_pathc; ++i) {
+            filenames.push_back(std::string(glob_result.gl_pathv[i]));
+        }
+    }
+
+    globfree(&glob_result);
+    return filenames;
+}
+#endif
+
 /**
  * @brief updateprompt updates prompt with the current user/location
  * @param api
@@ -124,12 +146,6 @@ MegaCmdExecuter::MegaCmdExecuter(MegaApi
     api->addTransferListener(globalTransferListener);
     cwd = UNDEF;
     fsAccessCMD = new MegaFileSystemAccess();
-    mtxSyncMap.init(false);
-    mtxWebDavLocations.init(false);
-    mtxFtpLocations.init(false);
-#ifdef ENABLE_BACKUPS
-    mtxBackupsMap.init(true);
-#endif
     session = NULL;
 }
 
@@ -163,7 +179,7 @@ void MegaCmdExecuter::listtrees()
         MegaShare *share = msl->get(i);
         MegaNode *n = api->getNodeByHandle(share->getNodeHandle());
 
-        OUTSTREAM << "INSHARE on " << share->getUser() << ":" << n->getName() << " (" << getAccessLevelStr(share->getAccess()) << ")" << endl;
+        OUTSTREAM << "INSHARE on //from/" << share->getUser() << ":" << n->getName() << " (" << getAccessLevelStr(share->getAccess()) << ")" << endl;
         delete n;
     }
 
@@ -601,6 +617,11 @@ vector <string> * MegaCmdExecuter::nodes
             delete []nodepath;
         }
 
+        if (string(ptr).find("//from/") == 0)
+        {
+            pathPrefix.insert(0,"//from/");
+        }
+
         deque<string> c;
         getPathParts(rest, &c);
 
@@ -616,6 +637,22 @@ vector <string> * MegaCmdExecuter::nodes
         }
         delete baseNode;
     }
+    else if (!strncmp(ptr,"//from/",max(3,min((int)strlen(ptr)-1,7)))) //pattern trying to match inshares
+    {
+        unique_ptr<MegaShareList> inShares(api->getInSharesList());
+        if (inShares)
+        {
+            for (int i = 0; i < inShares->size(); i++)
+            {
+                unique_ptr<MegaNode> n(api->getNodeByHandle(inShares->get(i)->getNodeHandle()));
+                string tomatch = string("//from/")+inShares->get(i)->getUser() + ":"+n->getName();
+                if (patternMatches(tomatch.c_str(), ptr, false))
+                {
+                    pathsMatching->push_back(tomatch);
+                }
+            }
+        }
+    }
 
     return pathsMatching;
 }
@@ -774,13 +811,27 @@ MegaNode * MegaCmdExecuter::getBaseNode(
         baseNode = api->getInboxNode();
         rest = thepath.substr(5);
     }
-    else if (thepath.find("/") == 0 )
+    else if (thepath.find("/") == 0 && !(thepath.find("//from/") == 0 ))
     {
+        if ( thepath.find("//f") == 0 && string("//from/").find(thepath.substr(0,thepath.find("*"))) == 0)
+        {
+            return NULL;
+        }
         baseNode = api->getRootNode();
         rest = thepath.substr(1);
     }
+    else if ( thepath == "//from/*" )
+    {
+        return NULL;
+    }
     else
     {
+        bool from = false;
+        if  (thepath.find("//from/") == 0 && thepath != "//from/*" )
+        {
+            thepath = thepath.substr(7);
+            from = true;
+        }
         size_t possep = thepath.find('/');
         string base = thepath.substr(0,possep);
         size_t possepcol = base.find(":");
@@ -821,7 +872,7 @@ MegaNode * MegaCmdExecuter::getBaseNode(
                 rest = thepath.substr(possep+1);
             }
         }
-        else
+        else if (!from)
         {
             baseNode = api->getNodeByHandle(cwd);
             rest = thepath;
@@ -871,6 +922,14 @@ bool MegaCmdExecuter::checkAndInformPSA(
     m_time_t now = m_time();
     if ( enforce || (now - sandboxCMD->timeOfPSACheck > 86400) )
     {
+        MegaUser *u = api->getMyUser();
+        if (!u)
+        {
+            LOG_debug << "No PSA request (not logged into an account)";
+            return toret; //Not logged in, no reason to get PSA
+        }
+        delete u;
+
         sandboxCMD->timeOfPSACheck = now;
 
         LOG_verbose << "Getting PSA";
@@ -995,7 +1054,6 @@ vector <MegaNode*> * MegaCmdExecuter::no
     string rest;
     MegaNode *baseNode = getBaseNode(ptr, rest);
 
-
     if (baseNode)
     {
         if (!rest.size())
@@ -1018,6 +1076,26 @@ vector <MegaNode*> * MegaCmdExecuter::no
         }
         delete baseNode;
     }
+    else if (!strncmp(ptr,"//from/",max(3,min((int)strlen(ptr)-1,7)))) //pattern trying to match inshares
+    {
+        unique_ptr<MegaShareList> inShares(api->getInSharesList());
+        if (inShares)
+        {
+            for (int i = 0; i < inShares->size(); i++)
+            {
+                MegaNode* n = api->getNodeByHandle(inShares->get(i)->getNodeHandle());
+                string tomatch = string("//from/")+inShares->get(i)->getUser() + ":"+n->getName();
+                if (patternMatches(tomatch.c_str(), ptr, false))
+                {
+                    nodesMatching->push_back(n);
+                }
+                else
+                {
+                    delete n;
+                }
+            }
+        }
+    }
 
     return nodesMatching;
 }
@@ -1361,15 +1439,13 @@ void MegaCmdExecuter::createOrModifyBack
 {
     string locallocal;
     fsAccessCMD->path2local(&local, &locallocal);
-    FileAccess *fa = fsAccessCMD->newfileaccess();
+    std::unique_ptr<FileAccess> fa = fsAccessCMD->newfileaccess();
     if (!fa->isfolder(&locallocal))
     {
         setCurrentOutCode(MCMD_NOTFOUND);
         LOG_err << "Local path must be an existing folder: " << local;
-        delete fa;
         return;
     }
-    delete fa;
 
 
     int64_t period = -1;
@@ -1473,13 +1549,26 @@ void MegaCmdExecuter::createOrModifyBack
 
 void MegaCmdExecuter::printTreeSuffix(int depth, vector<bool> &lastleaf)
 {
+#ifdef _WIN32
+    const wchar_t *c0 = L" ";
+    const wchar_t *c1 = L"\u2502";
+    const wchar_t *c2 = L"\u2514";
+    const wchar_t *c3 = L"\u251c";
+    const wchar_t *c4 = L"\u2500\u2500";
+#else
+    const char *c0 = " ";
+    const char *c1 = "\u2502";
+    const char *c2 = "\u2514";
+    const char *c3 = "\u251c";
+    const char *c4 = "\u2500\u2500";
+#endif
     for (int i = 0; i < depth-1; i++)
     {
-        OUTSTREAM << (lastleaf.at(i)?" ":"\u2502") << "   ";
+        OUTSTREAM << (lastleaf.at(i)?c0:c1) << "   ";
     }
     if (lastleaf.size())
     {
-        OUTSTREAM << (lastleaf.back()?"\u2514":"\u251c") << "\u2500\u2500 ";
+        OUTSTREAM << (lastleaf.back()?c2:c3) << c4 << " ";
     }
 }
 
@@ -1683,15 +1772,14 @@ bool MegaCmdExecuter::TestCanWriteOnCont
 
     string localcontainingFolder;
     fsAccessCMD->path2local(&containingFolder, &localcontainingFolder);
-    FileAccess *fa = fsAccessCMD->newfileaccess();
+    std::unique_ptr<FileAccess> fa = fsAccessCMD->newfileaccess();
     if (!fa->isfolder(&localcontainingFolder))
     {
-        delete fa;
         setCurrentOutCode(MCMD_INVALIDTYPE);
         LOG_err << containingFolder << " is not a valid Download Folder";
         return false;
     }
-    delete fa;
+
     if (!canWrite(containingFolder))
     {
         setCurrentOutCode(MCMD_NOTPERMITTED);
@@ -1724,6 +1812,12 @@ MegaContactRequest * MegaCmdExecuter::ge
 string MegaCmdExecuter::getDisplayPath(string givenPath, MegaNode* n)
 {
     char * pathToNode = api->getNodePath(n);
+    if (!pathToNode)
+    {
+        LOG_err << " GetNodePath failed for: " << givenPath;
+        return givenPath;
+    }
+
     char * pathToShow = pathToNode;
 
     string pathRelativeTo = "NULL";
@@ -2202,6 +2296,8 @@ bool MegaCmdExecuter::actUponFetchNodes(
         {
             delete cwdNode;
         }
+
+        informStateListeners("loged:"); // tell the clients login ended, before providing them the first prompt
         updateprompt(api, cwd);
         LOG_debug << " Fetch nodes correctly";
         return true;
@@ -2969,15 +3065,13 @@ void MegaCmdExecuter::uploadNode(string
 
     string locallocal;
     fsAccessCMD->path2local(&path, &locallocal);
-    FileAccess *fa = fsAccessCMD->newfileaccess();
+    std::unique_ptr<FileAccess> fa = fsAccessCMD->newfileaccess();
     if (!fa->fopen(&locallocal, true, false))
     {
         setCurrentOutCode(MCMD_NOTFOUND);
         LOG_err << "Unable to open local path: " << path;
-        delete fa;
         return;
     }
-    delete fa;
 
     MegaCmdTransferListener *megaCmdTransferListener = NULL;
     if (!background)
@@ -3733,10 +3827,8 @@ bool MegaCmdExecuter::IsFolder(string pa
 #endif
     string localpath;
     fsAccessCMD->path2local(&path, &localpath);
-    FileAccess *fa = fsAccessCMD->newfileaccess();
-    bool destinyIsFolder = fa->isfolder(&localpath);
-    delete fa;
-    return destinyIsFolder;
+    std::unique_ptr<FileAccess> fa = fsAccessCMD->newfileaccess();
+    return fa->isfolder(&localpath);
 }
 
 void MegaCmdExecuter::printTransfersHeader(const unsigned int PATHSIZE, bool printstate)
@@ -3773,7 +3865,7 @@ void MegaCmdExecuter::printTransfer(Mega
     else if (transfer->isBackupTransfer())
     {
 #ifdef _WIN32
-        OUTSTREAM << "S";
+        OUTSTREAM << "B";
 #else
         OUTSTREAM << "\u23eb";
 #endif
@@ -3865,8 +3957,121 @@ void MegaCmdExecuter::printTransfer(Mega
     OUTSTREAM << endl;
 }
 
-void MegaCmdExecuter::printSyncHeader(const unsigned int PATHSIZE)
+void MegaCmdExecuter::printTransferColumnDisplayer(ColumnDisplayer *cd, MegaTransfer *transfer, bool printstate)
+{
+    //Direction
+    string type;
+#ifdef _WIN32
+    type += getutf8fromUtf16((transfer->getType() == MegaTransfer::TYPE_DOWNLOAD)?L"\u25bc":L"\u25b2");
+#else
+    type += (transfer->getType() == MegaTransfer::TYPE_DOWNLOAD)?"\u21d3":"\u21d1";
+#endif
+    //TODO: handle TYPE_LOCAL_TCP_DOWNLOAD
+
+    //type (transfer/normal)
+    if (transfer->isSyncTransfer())
+    {
+#ifdef _WIN32
+        type += getutf8fromUtf16(L"\u21a8");
+#else
+        type += "\u21f5";
+#endif
+    }
+#ifdef ENABLE_BACKUPS
+    else if (transfer->isBackupTransfer())
+    {
+#ifdef _WIN32
+        type += getutf8fromUtf16(L"\u2191");
+#else
+        type += "\u23eb";
+#endif
+    }
+#endif
+
+    cd->addValue("TYPE",type);
+    cd->addValue("TAG", SSTR(transfer->getTag())); //TODO: do SSTR within ColumnDisplayer
+
+    if (transfer->getType() == MegaTransfer::TYPE_DOWNLOAD)
+    {
+        // source
+        MegaNode * node = api->getNodeByHandle(transfer->getNodeHandle());
+        if (node)
+        {
+            char * nodepath = api->getNodePath(node);
+            cd->addValue("SOURCEPATH",nodepath);
+            delete []nodepath;
+
+            delete node;
+        }
+        else
+        {
+            globalTransferListener->completedTransfersMutex.lock();
+            cd->addValue("SOURCEPATH",globalTransferListener->completedPathsByHandle[transfer->getNodeHandle()]);
+            globalTransferListener->completedTransfersMutex.unlock();
+        }
+
+        //destination
+        string dest = transfer->getParentPath() ? transfer->getParentPath() : "";
+        dest.append(transfer->getFileName());
+        cd->addValue("DESTINYPATH",dest);
+    }
+    else
+    {
+        //source
+        string source(transfer->getParentPath()?transfer->getParentPath():"");
+        source.append(transfer->getFileName());
+
+        cd->addValue("SOURCEPATH",source);
+
+        //destination
+        MegaNode * parentNode = api->getNodeByHandle(transfer->getParentHandle());
+        if (parentNode)
+        {
+            char * parentnodepath = api->getNodePath(parentNode);
+            cd->addValue("DESTINYPATH",parentnodepath);
+            delete []parentnodepath;
+
+            delete parentNode;
+        }
+        else
+        {
+            cd->addValue("DESTINYPATH","---------");
+
+            LOG_warn << "Could not find destination (parent handle "<< ((transfer->getParentHandle()==INVALID_HANDLE)?" invalid":" valid")
+                     <<" ) for upload transfer. Source=" << transfer->getParentPath() << transfer->getFileName();
+        }
+    }
+
+    //progress
+    float percent;
+    if (transfer->getTotalBytes() == 0)
+    {
+        percent = 0;
+    }
+    else
+    {
+        percent = float(transfer->getTransferredBytes()*1.0/transfer->getTotalBytes());
+    }
+
+    stringstream osspercent;
+    osspercent << percentageToText(percent) << " of " << getFixLengthString(sizeToText(transfer->getTotalBytes()),10,' ',true);
+    cd->addValue("PROGRESS",osspercent.str());
+
+    //state
+    if (printstate)
+    {
+        cd->addValue("STATE",getTransferStateStr(transfer->getState()));
+    }
+}
+
+void MegaCmdExecuter::printSyncHeader(const unsigned int PATHSIZE, ColumnDisplayer *cd)
 {
+    if (cd)
+    {
+        cd->addHeader("LOCALPATH", false);
+        cd->addHeader("REMOTEPATH", false);
+        return;
+    }
     OUTSTREAM << "ID ";
     OUTSTREAM << getFixLengthString("LOCALPATH ", PATHSIZE) << " ";
     OUTSTREAM << getFixLengthString("REMOTEPATH ", PATHSIZE) << " ";
@@ -3877,7 +4082,6 @@ void MegaCmdExecuter::printSyncHeader(co
     OUTSTREAM << getRightAlignedString("FILES", 6) << " ";
     OUTSTREAM << getRightAlignedString("DIRS", 6);
     OUTSTREAM << endl;
-
 }
 
 #ifdef ENABLE_BACKUPS
@@ -4091,8 +4295,57 @@ void MegaCmdExecuter::printBackup(backup
 }
 #endif
 
-void MegaCmdExecuter::printSync(int i, string key, const char *nodepath, sync_struct * thesync, MegaNode *n, long long nfiles, long long nfolders, const unsigned int PATHSIZE)
+void MegaCmdExecuter::printSync(int i, string key, const char *nodepath, sync_struct * thesync, MegaNode *n, long long nfiles, long long nfolders, const unsigned int PATHSIZE, megacmd::ColumnDisplayer *cd)
 {
+    if (cd)
+    {
+        cd->addValue("ID", SSTR(i));
+        cd->addValue("LOCALPATH", key);
+        cd->addValue("REMOTEPATH", nodepath);
+
+        string sstate(key);
+        sstate = rtrim(sstate, '/');
+    #ifdef _WIN32
+        sstate = rtrim(sstate, '\\');
+    #endif
+        string psstate;
+        fsAccessCMD->path2local(&sstate,&psstate);
+        int statepath = api->syncPathState(&psstate);
+
+        MegaSync *msync = api->getSyncByNode(n);
+        string syncstate = "REMOVED";
+        if (msync)
+        {
+            syncstate = getSyncStateStr(msync->getState());
+        }
+
+        string statetoprint;
+        if (thesync->active)
+        {
+            statetoprint = syncstate;
+        }
+        else
+        {
+            if (msync)
+            {
+                statetoprint = "Disabling:";
+                statetoprint+=syncstate;
+            }
+            else
+            {
+                statetoprint = "Disabled";
+            }
+        }
+        delete msync;
+        cd->addValue("ActState", statetoprint);
+        cd->addValue("SyncState", getSyncPathStateStr(statepath));
+        cd->addValue("SIZE", sizeToText(api->getSize(n)));
+        cd->addValue("FILES", SSTR(nfiles));
+        cd->addValue("DIRS", SSTR(nfolders));
+
+        return;
+    }
+
     //tag
     OUTSTREAM << getRightAlignedString(SSTR(i),2) << " ";
 
@@ -4979,6 +5232,72 @@ bool MegaCmdExecuter::printUserAttribute
     return false;
 }
 
+bool MegaCmdExecuter::setProxy(const std::string &url, const std::string &username, const std::string &password, int proxyType)
+{
+    MegaProxy mpx;
+
+    if (url.size())
+    {
+        mpx.setProxyURL(url.c_str());
+    }
+
+    if (username.size())
+    {
+        mpx.setCredentials(username.c_str(), password.c_str());
+    }
+
+    mpx.setProxyType(proxyType);
+
+    std::vector<MegaApi *> megaapis;
+    //TODO: add apiFolders to that list
+    megaapis.push_back(api);
+    bool failed = false;
+    for (auto api: megaapis)
+    {
+        MegaCmdListener *megaCmdListener = new MegaCmdListener(NULL);
+        api->setProxySettings(&mpx, megaCmdListener);
+        megaCmdListener->wait();
+        if (checkNoErrors(megaCmdListener->getError(), "(un)setting proxy"))
+        {
+            //TODO: connectivity check! // review connectivity check branch
+        }
+        else
+        {
+            failed = true;
+        }
+        delete megaCmdListener;
+    }
+
+    if (!failed)
+    {
+        ConfigurationManager::savePropertyValue("proxy_url", mpx.getProxyURL()?mpx.getProxyURL():"");
+        ConfigurationManager::savePropertyValue("proxy_type", mpx.getProxyType());
+
+        ConfigurationManager::savePropertyValue("proxy_username", mpx.getUsername()?mpx.getUsername():"");
+        ConfigurationManager::savePropertyValue("proxy_password", mpx.getPassword()?mpx.getPassword():"");
+
+        if (mpx.getProxyType() == MegaProxy::PROXY_NONE)
+        {
+            OUTSTREAM << "Proxy unset correctly" << endl ;
+        }
+        else
+        {
+            OUTSTREAM << "Proxy set: " << (mpx.getProxyURL()?mpx.getProxyURL():"")
+                      << " type = " << getProxyTypeStr(mpx.getProxyType()) << endl;
+
+            broadcastMessage(string("Using proxy: ").append((mpx.getProxyURL()?mpx.getProxyURL():""))
+                             .append(" type = ").append(getProxyTypeStr(mpx.getProxyType())), true);
+        }
+    }
+    else
+    {
+        LOG_err << "Unable to configure proxy";
+        broadcastMessage("Unable to configure proxy", true);
+    }
+
+    return !failed;
+}
+
 void MegaCmdExecuter::executecommand(vector<string> words, map<string, int> *clflags, map<string, string> *cloptions)
 {
     MegaNode* n = NULL;
@@ -5758,7 +6077,7 @@ void MegaCmdExecuter::executecommand(vec
                     }
                     delete megaCmdListener;
                 }
-                else
+                else //TODO: detect if referenced file within public link and in that case, do login and cat it
                 {
                     LOG_err << "Public link is not a file";
                     setCurrentOutCode(MCMD_EARGS);
@@ -6055,8 +6374,21 @@ void MegaCmdExecuter::executecommand(vec
                         megaCmdListener2->wait();
                         if (checkNoErrors(megaCmdListener2->getError(), "access folder link " + publicLink))
                         {
-                            MegaNode *folderRootNode = apiFolder->getRootNode();
-                            if (folderRootNode)
+                            MegaNode *nodeToDownload = NULL;
+                            bool usedRoot = false;
+                            string shandle = getPublicLinkHandle(publicLink);
+                            if (shandle.size())
+                            {
+                                handle thehandle = apiFolder->base64ToHandle(shandle.c_str());
+                                nodeToDownload = apiFolder->getNodeByHandle(thehandle);
+                            }
+                            else
+                            {
+                                nodeToDownload = apiFolder->getRootNode();
+                                usedRoot = true;
+                            }
+
+                            if (nodeToDownload)
                             {
                                 if (destinyIsFolder && getFlag(clflags,"m"))
                                 {
@@ -6065,7 +6397,7 @@ void MegaCmdExecuter::executecommand(vec
                                         path=path.substr(0,path.size()-1);
                                     }
                                 }
-                                MegaNode *authorizedNode = apiFolder->authorizeNode(folderRootNode);
+                                MegaNode *authorizedNode = apiFolder->authorizeNode(nodeToDownload);
                                 if (authorizedNode != NULL)
                                 {
                                     downloadNode(path, api, authorizedNode, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
@@ -6074,14 +6406,21 @@ void MegaCmdExecuter::executecommand(vec
                                 else
                                 {
                                     LOG_debug << "Node couldn't be authorized: " << publicLink << ". Downloading as non-loged user";
-                                    downloadNode(path, apiFolder, folderRootNode, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
+                                    downloadNode(path, apiFolder, nodeToDownload, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
                                 }
-                                delete folderRootNode;
+                                delete nodeToDownload;
                             }
                             else
                             {
                                 setCurrentOutCode(MCMD_INVALIDSTATE);
-                                LOG_err << "Couldn't get root folder for folder link";
+                                if (usedRoot)
+                                {
+                                    LOG_err << "Couldn't get root folder for folder link";
+                                }
+                                else
+                                {
+                                    LOG_err << "Failed to get node corresponding to handle within public link " << shandle;
+                                }
                             }
                         }
                         delete megaCmdListener2;
@@ -6525,16 +6864,48 @@ void MegaCmdExecuter::executecommand(vec
                         {
                             words[i] = getLPWD();
                         }
-                        uploadNode(words[i], api, n, newname, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
+
+#ifdef HAVE_GLOB_H
+                        if (!newname.size()
+#ifdef MEGACMDEXECUTER_FILESYSTEM
+                                && !fs::exists(words[i])
+#endif
+                                && hasWildCards(words[i]))
+                        {
+                            auto paths = resolvewildcard(words[i]);
+                            if (!paths.size())
+                            {
+                                setCurrentOutCode(MCMD_NOTFOUND);
+                                LOG_err << words[i] << " not found";
+                            }
+                            for (auto path : paths)
+                            {
+                                uploadNode(path, api, n, newname, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
+                            }
+                        }
+                        else
+#endif
+                        {
+                            uploadNode(words[i], api, n, newname, background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
+                        }
                     }
                 }
                 else if (words.size() == 3 && !IsFolder(words[1])) //replace file
                 {
-                    MegaNode *pn = api->getNodeByHandle(n->getParentHandle());
+                    unique_ptr<MegaNode> pn(api->getNodeByHandle(n->getParentHandle()));
                     if (pn)
                     {
-                        uploadNode(words[1], api, pn, n->getName(), background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
-                        delete pn;
+#if defined(HAVE_GLOB_H) && defined(MEGACMDEXECUTER_FILESYSTEM)
+                        if (!fs::exists(words[1]) && hasWildCards(words[1]))
+                        {
+                            LOG_err << "Invalid target for wildcard expression: " << words[1] << ". Folder expected";
+                            setCurrentOutCode(MCMD_INVALIDTYPE);
+                        }
+                        else
+#endif
+                        {
+                            uploadNode(words[1], api, pn.get(), n->getName(), background, ignorequotawarn, clientID, megaCmdMultiTransferListener);
+                        }
                     }
                     else
                     {
@@ -7373,6 +7744,7 @@ void MegaCmdExecuter::executecommand(vec
                 if (n)
                 {
                     char * nodepath = api->getNodePath(n);
+                    ColumnDisplayer cd;
 
                     if (( id == i ) || (( id == -1 ) && ( words[1] == thesync->localpath )))
                     {
@@ -7450,14 +7822,17 @@ void MegaCmdExecuter::executecommand(vec
                         if (!headershown)
                         {
                             headershown = true;
-                            printSyncHeader(PATHSIZE);
+                            printSyncHeader(PATHSIZE, &cd);
                         }
 
-                        printSync(i, key, nodepath, thesync, n, nfiles, nfolders, PATHSIZE);
+                        printSync(i, key, nodepath, thesync, n, nfiles, nfolders, PATHSIZE, &cd);
 
                     }
                     delete n;
                     delete []nodepath;
+                    OUTSTRINGSTREAM oss;
+                    cd.print(oss, getintOption(cloptions, "client-width", getNumberOfCols(75)));
+                    OUTSTREAM << oss.str();
                 }
                 else
                 {
@@ -7488,6 +7863,7 @@ void MegaCmdExecuter::executecommand(vec
         }
         else if (words.size() == 1)
         {
+            ColumnDisplayer cd;
             map<string, sync_struct *>::const_iterator itr;
             int i = 0;
             for (itr = ConfigurationManager::configuredSyncs.begin(); itr != ConfigurationManager::configuredSyncs.end(); ++itr)
@@ -7497,7 +7873,7 @@ void MegaCmdExecuter::executecommand(vec
                 if (!headershown)
                 {
                     headershown = true;
-                    printSyncHeader(PATHSIZE);
+                    printSyncHeader(PATHSIZE, &cd);
                 }
                 if (n)
                 {
@@ -7507,17 +7883,21 @@ void MegaCmdExecuter::executecommand(vec
                     getInfoFromFolder(n, api, &nfiles, &nfolders);
 
                     char * nodepath = api->getNodePath(n);
-                    printSync(i++, ( *itr ).first, nodepath, thesync, n, nfiles, nfolders, PATHSIZE);
+                    printSync(i++, ( *itr ).first, nodepath, thesync, n, nfiles, nfolders, PATHSIZE, &cd);
 
                     delete n;
                     delete []nodepath;
                 }
                 else
                 {
-                    printSync(i++, ( *itr ).first, "NOT FOUND", thesync, n, -1, -1, PATHSIZE);
+                    printSync(i++, ( *itr ).first, "NOT FOUND", thesync, n, -1, -1, PATHSIZE, &cd);
                     setCurrentOutCode(MCMD_NOTFOUND);
                 }
             }
+            OUTSTRINGSTREAM oss;
+            cd.print(oss, getintOption(cloptions, "client-width", getNumberOfCols(75)));
+            OUTSTREAM << oss.str();
+
         }
         else
         {
@@ -7574,6 +7954,7 @@ void MegaCmdExecuter::executecommand(vec
     }
     else if (words[0] == "login")
     {
+        LoginGuard loginGuard;
         int clientID = getintOption(cloptions, "clientID", -1);
 
         if (!api->isLoggedIn())
@@ -8681,11 +9062,11 @@ void MegaCmdExecuter::executecommand(vec
         if (u)
         {
             MegaCmdListener *megaCmdListener = new MegaCmdListener(NULL);
-            api->getExtendedAccountDetails(true, true, true, megaCmdListener);
+            api->getSpecificAccountDetails(true, false, false, -1, megaCmdListener);
             megaCmdListener->wait();
             if (checkNoErrors(megaCmdListener->getError(), "failed to get used storage"))
             {
-                MegaAccountDetails *details = megaCmdListener->getRequest()->getMegaAccountDetails();
+                unique_ptr<MegaAccountDetails> details(megaCmdListener->getRequest()->getMegaAccountDetails());
                 if (details)
                 {
                     long long usedTotal = 0;
@@ -8696,45 +9077,46 @@ void MegaCmdExecuter::executecommand(vec
 
                     long long storageMax = details->getStorageMax();
 
-                    MegaNode *n = api->getRootNode();
-                    if (n)
-                    {
-                        rootStorage = details->getStorageUsed(n->getHandle());
-                        OUTSTREAM << "Cloud drive:          "
-                                  << getFixLengthString(sizeToText(rootStorage, true, humanreadable), 12, ' ', true) << " in "
-                                  << getFixLengthString(SSTR(details->getNumFiles(n->getHandle())),7,' ',true) << " file(s) and "
-                                  << getFixLengthString(SSTR(details->getNumFolders(n->getHandle())),7,' ',true) << " folder(s)" << endl;
-                        delete n;
-                    }
+                    unique_ptr<MegaNode> root(api->getRootNode());
+                    unique_ptr<MegaNode> inbox(api->getInboxNode());
+                    unique_ptr<MegaNode> rubbish(api->getRubbishNode());
+                    unique_ptr<MegaNodeList> inShares(api->getInShares());
 
-                    n = api->getInboxNode();
-                    if (n)
+                    if (!root || !inbox || !rubbish)
                     {
-                        inboxStorage = details->getStorageUsed(n->getHandle());
-                        OUTSTREAM << "Inbox:                "
-                                  << getFixLengthString(sizeToText(inboxStorage, true, humanreadable), 12, ' ', true ) << " in "
-                                  << getFixLengthString(SSTR(details->getNumFiles(n->getHandle())),7,' ',true) << " file(s) and "
-                                  << getFixLengthString(SSTR(details->getNumFolders(n->getHandle())),7,' ',true) << " folder(s)" << endl;
-                        delete n;
+                        LOG_err << " Error retrieving storage details. Root node missing";
+                        return;
                     }
 
-                    n = api->getRubbishNode();
-                    if (n)
-                    {
-                        rubbishStorage = details->getStorageUsed(n->getHandle());
-                        OUTSTREAM << "Rubbish bin:          "
-                                  << getFixLengthString(sizeToText(rubbishStorage, true, humanreadable), 12, ' ', true) << " in "
-                                  << getFixLengthString(SSTR(details->getNumFiles(n->getHandle())),7,' ',true) << " file(s) and "
-                                  << getFixLengthString(SSTR(details->getNumFolders(n->getHandle())),7,' ',true) << " folder(s)" << endl;
-                        delete n;
-                    }
+                    MegaHandle rootHandle = root->getHandle();
+                    MegaHandle inboxHandle = inbox->getHandle();
+                    MegaHandle rubbishHandle = rubbish->getHandle();
+
+                    rootStorage = details->getStorageUsed(rootHandle);
+                    OUTSTREAM << "Cloud drive:          "
+                              << getFixLengthString(sizeToText(rootStorage, true, humanreadable), 12, ' ', true) << " in "
+                              << getFixLengthString(SSTR(details->getNumFiles(rootHandle)),7,' ',true) << " file(s) and "
+                              << getFixLengthString(SSTR(details->getNumFolders(rootHandle)),7,' ',true) << " folder(s)" << endl;
+
+
+                    inboxStorage = details->getStorageUsed(inboxHandle);
+                    OUTSTREAM << "Inbox:                "
+                              << getFixLengthString(sizeToText(inboxStorage, true, humanreadable), 12, ' ', true ) << " in "
+                              << getFixLengthString(SSTR(details->getNumFiles(inboxHandle)),7,' ',true) << " file(s) and "
+                              << getFixLengthString(SSTR(details->getNumFolders(inboxHandle)),7,' ',true) << " folder(s)" << endl;
 
-                    MegaNodeList *inshares = api->getInShares();
-                    if (inshares)
+                    rubbishStorage = details->getStorageUsed(rubbishHandle);
+                    OUTSTREAM << "Rubbish bin:          "
+                              << getFixLengthString(sizeToText(rubbishStorage, true, humanreadable), 12, ' ', true) << " in "
+                              << getFixLengthString(SSTR(details->getNumFiles(rubbishHandle)),7,' ',true) << " file(s) and "
+                              << getFixLengthString(SSTR(details->getNumFolders(rubbishHandle)),7,' ',true) << " folder(s)" << endl;
+
+
+                    if (inShares)
                     {
-                        for (int i = 0; i < inshares->size(); i++)
+                        for (int i = 0; i < inShares->size(); i++)
                         {
-                            n = inshares->get(i);
+                            n = inShares->get(i);
                             long long thisinshareStorage = details->getStorageUsed(n->getHandle());
                             insharesStorage += thisinshareStorage;
                             if (i == 0)
@@ -8752,12 +9134,8 @@ void MegaCmdExecuter::executecommand(vec
                                       << getFixLengthString(SSTR(details->getNumFolders(n->getHandle())),7,' ',true) << " folder(s)" << endl;
                         }
                     }
-                    delete inshares;
 
-                    usedTotal += rootStorage;
-                    usedTotal += inboxStorage;
-                    usedTotal += rubbishStorage;
-                    usedTotal += insharesStorage;
+                    usedTotal = sandboxCMD->receivedStorageSum;
 
                     float percent = float(usedTotal * 1.0 / storageMax);
                     if (percent < 0 ) percent = 0;
@@ -8782,12 +9160,13 @@ void MegaCmdExecuter::executecommand(vec
                     }
                     OUTSTREAM << endl;
 
-                    long long usedinVersions = details->getVersionStorageUsed();
+                    long long usedinVersions = details->getVersionStorageUsed(rootHandle)
+                            + details->getVersionStorageUsed(inboxHandle)
+                            + details->getVersionStorageUsed(rubbishHandle);
+
 
                     OUTSTREAM << "Total size taken up by file versions: "
                               << getFixLengthString(sizeToText(usedinVersions, true, humanreadable), 12, ' ', true) << endl;
-
-                    delete details;
                 }
             }
             delete megaCmdListener;
@@ -9032,10 +9411,23 @@ void MegaCmdExecuter::executecommand(vec
                             megaCmdListener2->wait();
                             if (checkNoErrors(megaCmdListener2->getError(), "access folder link " + publicLink))
                             {
-                                MegaNode *folderRootNode = apiFolder->getRootNode();
-                                if (folderRootNode)
+                                MegaNode *nodeToImport = NULL;
+                                bool usedRoot = false;
+                                string shandle = getPublicLinkHandle(publicLink);
+                                if (shandle.size())
                                 {
-                                    MegaNode *authorizedNode = apiFolder->authorizeNode(folderRootNode);
+                                    handle thehandle = apiFolder->base64ToHandle(shandle.c_str());
+                                    nodeToImport = apiFolder->getNodeByHandle(thehandle);
+                                }
+                                else
+                                {
+                                    nodeToImport = apiFolder->getRootNode();
+                                    usedRoot = true;
+                                }
+
+                                if (nodeToImport)
+                                {
+                                    MegaNode *authorizedNode = apiFolder->authorizeNode(nodeToImport);
                                     if (authorizedNode != NULL)
                                     {
                                         MegaCmdListener *megaCmdListener3 = new MegaCmdListener(apiFolder, NULL);
@@ -9060,12 +9452,19 @@ void MegaCmdExecuter::executecommand(vec
                                         setCurrentOutCode(MCMD_EUNEXPECTED);
                                         LOG_debug << "Node couldn't be authorized: " << publicLink;
                                     }
-                                    delete folderRootNode;
+                                    delete nodeToImport;
                                 }
                                 else
                                 {
                                     setCurrentOutCode(MCMD_INVALIDSTATE);
-                                    LOG_err << "Couldn't get root folder for folder link";
+                                    if (usedRoot)
+                                    {
+                                        LOG_err << "Couldn't get root folder for folder link";
+                                    }
+                                    else
+                                    {
+                                        LOG_err << "Failed to get node corresponding to handle within public link " << shandle;
+                                    }
                                 }
                             }
                             delete megaCmdListener2;
@@ -9221,7 +9620,7 @@ void MegaCmdExecuter::executecommand(vec
     }
     else if (words[0] == "version")
     {
-        OUTSTREAM << "MEGAcmd version: " << MEGACMD_MAJOR_VERSION << "." << MEGACMD_MINOR_VERSION << "." << MEGACMD_MICRO_VERSION << ": code " << MEGACMD_CODE_VERSION << endl;
+        OUTSTREAM << "MEGAcmd version: " << MEGACMD_MAJOR_VERSION << "." << MEGACMD_MINOR_VERSION << "." << MEGACMD_MICRO_VERSION << "." << MEGACMD_BUILD_ID << ": code " << MEGACMD_CODE_VERSION << endl;
 
         MegaCmdListener *megaCmdListener = new MegaCmdListener(NULL);
         api->getLastAvailableVersion("BdARkQSQ",megaCmdListener);
@@ -9804,6 +10203,10 @@ void MegaCmdExecuter::executecommand(vec
         vector<MegaTransfer *>::iterator itDLs = transfersDLToShow.begin();
         vector<MegaTransfer *>::iterator itUPs = transfersUPToShow.begin();
 
+        ColumnDisplayer cd;
+        cd.addHeader("SOURCEPATH", false);
+        cd.addHeader("DESTINYPATH", false);
+
         for (unsigned int i=0;i<showndl+shownup+shownCompleted; i++)
         {
             MegaTransfer *transfer = NULL;
@@ -9831,7 +10234,6 @@ void MegaCmdExecuter::executecommand(vec
                     OUTSTREAM << "            " << (downloadpaused?"DOWNLOADS":"") << ((uploadpaused && downloadpaused)?" AND ":"")
                               << (uploadpaused?"UPLOADS":"") << " ARE PAUSED " << endl;
                 }
-                printTransfersHeader(PATHSIZE);
             }
             if (i==(unsigned int)limit) //we are in the extra one (not to be shown)
             {
@@ -9843,13 +10245,16 @@ void MegaCmdExecuter::executecommand(vec
                 break;
             }
 
-            printTransfer(transfer, PATHSIZE);
+            printTransferColumnDisplayer(&cd, transfer);
 
             if (deleteTransfer)
             {
                 delete transfer;
             }
         }
+        OUTSTRINGSTREAM oss;
+        cd.print(oss, getintOption(cloptions, "client-width", getNumberOfCols(75)));
+        OUTSTREAM << oss.str();
     }
     else if (words[0] == "locallogout")
     {
@@ -9857,6 +10262,73 @@ void MegaCmdExecuter::executecommand(vec
         cwd = UNDEF;
         return;
     }
+    else if (words[0] == "proxy")
+    {
+        bool autoProxy = getFlag(clflags, "auto");
+        bool noneProxy = getFlag(clflags, "none");
+        int proxyType = -1;
+
+
+        string username = getOption(cloptions, "username", "");
+        string password;
+        if (username.size())
+        {
+            password = getOption(cloptions, "password", "");
+            if (!password.size())
+            {
+                password = askforUserResponse("Enter password: ");
+            }
+        }
+
+        string urlProxy;
+        if (words.size() > 1)
+        {
+            proxyType = MegaProxy::PROXY_CUSTOM;
+            urlProxy = words[1];
+        }
+        else if (autoProxy)
+        {
+            proxyType = MegaProxy::PROXY_AUTO;
+        }
+        else if (noneProxy)
+        {
+            proxyType = MegaProxy::PROXY_NONE;
+        }
+
+        if (proxyType == -1)
+        {
+            int configuredProxyType = ConfigurationManager::getConfigurationValue("proxy_type", -1);
+            auto configuredProxyUrl = ConfigurationManager::getConfigurationSValue("proxy_url");
+
+            auto configuredProxyUsername = ConfigurationManager::getConfigurationSValue("proxy_username");
+            auto configuredProxyPassword = ConfigurationManager::getConfigurationSValue("proxy_password");
+
+            OUTSTREAM << "Proxy configured.";
+            if (configuredProxyType != 1)
+            {
+                OUTSTREAM << " type " << configuredProxyType;
+            }
+
+            if (configuredProxyUrl.size())
+            {
+                OUTSTREAM << endl << " URL = " << configuredProxyUrl;
+            }
+            if (configuredProxyUsername.size())
+            {
+                OUTSTREAM << endl << " username = " << configuredProxyUsername;
+            }
+            if (configuredProxyUrl.size())
+            {
+                OUTSTREAM << endl << " password = " << configuredProxyPassword;
+            }
+            OUTSTREAM << endl;
+        }
+        else
+        {
+            setProxy(urlProxy, username, password, proxyType);
+        }
+
+    }
     else
     {
         setCurrentOutCode(MCMD_EARGS);
@@ -9864,3 +10336,4 @@ void MegaCmdExecuter::executecommand(vec
     }
 }
 
+}//end namespace
--- a/src/megacmdexecuter.h
+++ b/src/megacmdexecuter.h
@@ -23,6 +23,7 @@
 #include "megacmdsandbox.h"
 #include "listeners.h"
 
+namespace megacmd {
 class MegaCmdExecuter
 {
 private:
@@ -33,12 +34,12 @@ private:
     MegaCMDLogger *loggerCMD;
     MegaCmdSandbox *sandboxCMD;
     MegaCmdGlobalTransferListener *globalTransferListener;
-    mega::MegaMutex mtxSyncMap;
-    mega::MegaMutex mtxWebDavLocations; //TODO: destroy these two
-    mega::MegaMutex mtxFtpLocations;
+    std::mutex mtxSyncMap;
+    std::mutex mtxWebDavLocations;
+    std::mutex mtxFtpLocations;
 
 #ifdef ENABLE_BACKUPS
-    mega::MegaMutex mtxBackupsMap;
+    std::recursive_mutex mtxBackupsMap;
 #endif
 
     // login/signup e-mail address
@@ -151,7 +152,7 @@ public:
 
     void printTransfersHeader(const unsigned int PATHSIZE, bool printstate=true);
     void printTransfer(mega::MegaTransfer *transfer, const unsigned int PATHSIZE, bool printstate=true);
-    void printSyncHeader(const unsigned int PATHSIZE);
+    void printTransferColumnDisplayer(ColumnDisplayer *cd, mega::MegaTransfer *transfer, bool printstate=true);
 
 #ifdef ENABLE_BACKUPS
 
@@ -162,7 +163,8 @@ public:
     void printBackup(int tag, mega::MegaBackup *backup, const char *timeFormat, const unsigned int PATHSIZE, bool extendedinfo = false, bool showhistory = false, mega::MegaNode *parentnode = NULL);
     void printBackup(backup_struct *backupstruct, const char *timeFormat, const unsigned int PATHSIZE, bool extendedinfo = false, bool showhistory = false);
 #endif
-    void printSync(int i, std::string key, const char *nodepath, sync_struct * thesync, mega::MegaNode *n, long long nfiles, long long nfolders, const unsigned int PATHSIZE);
+    void printSyncHeader(const unsigned int PATHSIZE, ColumnDisplayer *cd = nullptr);
+    void printSync(int i, std::string key, const char *nodepath, sync_struct * thesync, mega::MegaNode *n, long long nfiles, long long nfolders, const unsigned int PATHSIZE, ColumnDisplayer *cd = nullptr);
 
     void doFind(mega::MegaNode* nodeBase, const char *timeFormat, std::map<std::string, int> *clflags, std::map<std::string, std::string> *cloptions, std::string word, int printfileinfo, std::string pattern, bool usepcre, mega::m_time_t minTime, mega::m_time_t maxTime, int64_t minSize, int64_t maxSize);
 
@@ -194,6 +196,8 @@ public:
     void addFtpLocation(mega::MegaNode *n, bool firstone, std::string name = std::string());
 #endif
     bool printUserAttribute(int a, std::string user, bool onlylist = false);
+    bool setProxy(const std::string &url, const std::string &username, const std::string &password, int proxyType);
 };
 
+}//end namespace
 #endif // MEGACMDEXECUTER_H
--- a/src/megacmd.h
+++ b/src/megacmd.h
@@ -41,6 +41,7 @@ using std::exception;
 #include "megaapi_impl.h"
 
 #define PROGRESS_COMPLETE -2
+namespace megacmd {
 
 typedef struct sync_struct
 {
@@ -110,7 +111,37 @@ enum confirmresponse
 void changeprompt(const char *newprompt);
 
 void informStateListener(std::string message, int clientID);
-void broadcastMessage(std::string message);
+void broadcastMessage(std::string message, bool keepIfNoListeners = false);
+void informStateListeners(std::string s);
+
+void appendGreetingStatusFirstListener(const std::string &msj);
+void removeGreetingStatusFirstListener(const std::string &msj);
+void appendGreetingStatusAllListener(const std::string &msj);
+void removeGreetingStatusAllListener(const std::string &msj);
+
+
+void setloginInAtStartup(bool value);
+bool getloginInAtStartup();
+
+/**
+ * @brief A class to ensure clients are properly informed of login in situations
+ */
+class LoginGuard {
+public:
+    LoginGuard()
+    {
+        appendGreetingStatusAllListener(std::string("login:"));
+        setloginInAtStartup(true);
+    }
+
+    ~LoginGuard()
+    {
+        removeGreetingStatusAllListener(std::string("login:"));
+        informStateListeners("loged:"); //send this even when failed!
+        setloginInAtStartup(false);
+    }
+};
+
 
 mega::MegaApi* getFreeApiFolder();
 void freeApiFolder(mega::MegaApi *apiFolder);
@@ -140,6 +171,5 @@ void informStateListenerByClientId(int c
 
 void informProgressUpdate(long long transferred, long long total, int clientID, std::string title = "");
 
-
-
+}//end namespace
 #endif
--- a/src/megacmdlogger.cpp
+++ b/src/megacmdlogger.cpp
@@ -34,11 +34,11 @@
 #endif
 #endif
 
-using namespace std;
 using namespace mega;
 
+namespace megacmd {
 // different outstreams for every thread. to gather all the output data
-MUTEX_CLASS threadLookups(false);
+std::mutex threadLookups;
 map<uint64_t, LoggedStream *> outstreams;
 map<uint64_t, int> threadLogLevel;
 map<uint64_t, int> threadoutCode;
@@ -50,7 +50,7 @@ LoggedStream LCOUT(&COUT);
 
 LoggedStream &getCurrentOut()
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     uint64_t currentThread = MegaThread::currentThreadId();
     if (outstreams.find(currentThread) == outstreams.end())
     {
@@ -71,7 +71,7 @@ bool interactiveThread()
 
     unsigned long long currentThread = MegaThread::currentThreadId();
 
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     if (outstreams.find(currentThread) == outstreams.end())
     {
         return true;
@@ -86,7 +86,7 @@ int getCurrentOutCode()
 {
     unsigned long long currentThread = MegaThread::currentThreadId();
 
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     if (threadoutCode.find(currentThread) == threadoutCode.end())
     {
         return 0; //default OK
@@ -102,7 +102,7 @@ CmdPetition * getCurrentPetition()
 {
     unsigned long long currentThread = MegaThread::currentThreadId();
 
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     if (threadpetition.find(currentThread) == threadpetition.end())
     {
         return NULL;
@@ -117,7 +117,7 @@ int getCurrentThreadLogLevel()
 {
     unsigned long long currentThread = MegaThread::currentThreadId();
 
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     if (threadLogLevel.find(currentThread) == threadLogLevel.end())
     {
         return -1;
@@ -132,7 +132,7 @@ bool getCurrentThreadIsCmdShell()
 {
     unsigned long long currentThread = MegaThread::currentThreadId();
 
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     if (threadIsCmdShell.find(currentThread) == threadIsCmdShell.end())
     {
         return false; //default not
@@ -146,31 +146,31 @@ bool getCurrentThreadIsCmdShell()
 
 void setCurrentThreadLogLevel(int level)
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     threadLogLevel[MegaThread::currentThreadId()] = level;
 }
 
 void setCurrentThreadOutStream(LoggedStream *s)
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     outstreams[MegaThread::currentThreadId()] = s;
 }
 
 void setCurrentThreadIsCmdShell(bool isit)
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     threadIsCmdShell[MegaThread::currentThreadId()] = isit;
 }
 
 void setCurrentOutCode(int outCode)
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     threadoutCode[MegaThread::currentThreadId()] = outCode;
 }
 
 void setCurrentPetition(CmdPetition *petition)
 {
-    MutexGuard g(threadLookups);
+    std::lock_guard<std::mutex> g(threadLookups);
     threadpetition[MegaThread::currentThreadId()] = petition;
 }
 
@@ -179,7 +179,7 @@ MegaCMDLogger::MegaCMDLogger()
 {
     this->output = &LCOUT;
     this->apiLoggerLevel = MegaApi::LOG_LEVEL_ERROR;
-    this->outputmutex = new MegaMutex(false);
+    this->outputmutex = new std::mutex();
 }
 
 MegaCMDLogger::~MegaCMDLogger()
@@ -199,7 +199,7 @@ void MegaCMDLogger::log(const char *time
         if (loglevel <= cmdLoggerLevel)
         {
 #ifdef _WIN32
-            MutexGuard g(*outputmutex);
+            std::lock_guard<std::mutex> g(*outputmutex);
             int oldmode;
             oldmode = _setmode(_fileno(stdout), _O_U8TEXT);
             *output << "[" << SimpleLogger::toStr(LogLevel(loglevel)) << ": " << time << "] " << message << endl;
@@ -233,7 +233,7 @@ void MegaCMDLogger::log(const char *time
                 return;
             }
 #ifdef _WIN32
-            MutexGuard g(*outputmutex);
+            std::lock_guard<std::mutex> g(*outputmutex);
             int oldmode;
             oldmode = _setmode(_fileno(stdout), _O_U8TEXT);
             *output << "[API:" << SimpleLogger::toStr(LogLevel(loglevel)) << ": " << time << "] " << message << endl;
@@ -261,3 +261,4 @@ int MegaCMDLogger::getMaxLogLevel()
     return max(max(getCurrentThreadLogLevel(), cmdLoggerLevel), apiLoggerLevel);
 }
 
+}//end namespace
--- a/src/megacmdlogger.h
+++ b/src/megacmdlogger.h
@@ -24,6 +24,7 @@
 
 #define OUTSTREAM getCurrentOut()
 
+namespace megacmd {
 class LoggedStream {
 public:
   LoggedStream(){out = NULL;}
@@ -74,14 +75,7 @@ public:
 
   LoggedStream const& operator<<(OUTSTREAMTYPE& (*F)(OUTSTREAMTYPE&)) const
   {
-      if (F == (OUTSTREAMTYPE& (*)(OUTSTREAMTYPE&) )(std::endl))
-      {
-          OUTSTRINGSTREAM os; os << "\n"; OUTSTRING s = os.str(); cm->sendPartialOutput(inf, &s); return *this;
-      }
-      else
-      {
-          std::cerr << "unable to identify f:" << std::endl;
-      }
+      OUTSTRINGSTREAM os; os << F; OUTSTRING s = os.str(); cm->sendPartialOutput(inf, &s); return *this;
       return *this;
   }
 
@@ -112,7 +106,7 @@ private:
     int apiLoggerLevel;
     int cmdLoggerLevel;
     LoggedStream * output;
-    mega::MegaMutex *outputmutex;
+    std::mutex *outputmutex;
 
 public:
     MegaCMDLogger();
@@ -143,4 +137,5 @@ public:
     }
 };
 
+}//end namespace
 #endif // MEGACMDLOGGER_H
--- a/src/megacmdplatform.h
+++ b/src/megacmdplatform.h
@@ -1,6 +1,7 @@
 #ifndef MEGACMDPLATFORM_H
 #define MEGACMDPLATFORM_H
 
+namespace megacmd {
 
 #ifdef __MACH__
 
@@ -9,4 +10,5 @@ bool registerUpdateDaemon();
 
 #endif
 
+}//end namespace
 #endif // MEGACMDPLATFORM_H
--- a/src/megacmdplatform.mm
+++ b/src/megacmdplatform.mm
@@ -9,6 +9,8 @@
 #include <sys/stat.h>
 #ifdef __MACH__
 
+namespace megacmd {
+
 char *runWithRootPrivileges(char *command)
 {
     OSStatus status;
@@ -129,5 +131,6 @@ bool registerUpdateDaemon()
     return false;
 }
 
+}// end of namespace
 
 #endif
--- a/src/megacmdsandbox.cpp
+++ b/src/megacmdsandbox.cpp
@@ -20,6 +20,7 @@
 
 using namespace mega;
 
+namespace megacmd {
 bool MegaCmdSandbox::isOverquota() const
 {
     return overquota;
@@ -41,6 +42,8 @@ void MegaCmdSandbox::resetSandBox()
     this->secondsOverQuota = 0;
     this->accounthasbeenblocked = false;
     this->storageStatus = 0;
+    this->receivedStorageSum = 0;
+    this->totalStorage = 0;
     this->timeOfPSACheck = 0;
     this->lastPSAnumreceived = -1;
 }
@@ -56,7 +59,10 @@ MegaCmdSandbox::MegaCmdSandbox()
     this->secondsOverQuota = 0;
     this->accounthasbeenblocked = false;
     this->storageStatus = 0;
+    this->receivedStorageSum = 0;
+    this->totalStorage = 0;
     this->timeOfPSACheck = 0;
     this->lastPSAnumreceived = -1;
 }
 
+}//end namespace
--- a/src/megacmdsandbox.h
+++ b/src/megacmdsandbox.h
@@ -23,6 +23,7 @@
 #include <ctime>
 #include <string>
 
+namespace megacmd {
 class MegaCmdSandbox
 {
 private:
@@ -41,6 +42,8 @@ public:
     bool accounthasbeenblocked;
     std::string reasonblocked;
     int storageStatus;
+    long long receivedStorageSum;
+    long long totalStorage;
 public:
     MegaCmdSandbox();
     bool isOverquota() const;
@@ -48,4 +51,5 @@ public:
     void resetSandBox();
 };
 
+}//end namespace
 #endif // MEGACMDSANDBOX_H
--- a/src/megacmdshell/megacmdshellcommunications.cpp
+++ b/src/megacmdshell/megacmdshellcommunications.cpp
@@ -71,6 +71,7 @@
         ( std::ostringstream() << std::dec << x ) ).str()
 #endif
 
+namespace megacmd {
 using namespace std;
 
 bool MegaCmdShellCommunications::serverinitiatedfromshell;
@@ -78,9 +79,9 @@ bool MegaCmdShellCommunications::registe
 bool MegaCmdShellCommunications::confirmResponse;
 bool MegaCmdShellCommunications::stopListener;
 bool MegaCmdShellCommunications::updating;
-::mega::Thread *MegaCmdShellCommunications::listenerThread;
+MegaThread *MegaCmdShellCommunications::listenerThread;
 SOCKET MegaCmdShellCommunications::newsockfd = INVALID_SOCKET;
-MegaMutex MegaCmdShellCommunications::megaCmdStdoutputing;
+std::mutex MegaCmdShellCommunications::megaCmdStdoutputing;
 
 bool MegaCmdShellCommunications::socketValid(SOCKET socket)
 {
@@ -174,29 +175,6 @@ bool is_pid_running(pid_t pid) {
 }
 #endif
 
-#ifdef __linux__
-std::string getCurrentExecPath()
-{
-    std::string path = ".";
-    pid_t pid = getpid();
-    char buf[20] = {0};
-    sprintf(buf,"%d",pid);
-    std::string _link = "/proc/";
-    _link.append( buf );
-    _link.append( "/exe");
-    char proc[PATH_MAX];
-    int ch = readlink(_link.c_str(),proc,PATH_MAX);
-    if (ch != -1) {
-        proc[ch] = 0;
-        path = proc;
-        std::string::size_type t = path.find_last_of("/");
-        path = path.substr(0,t);
-    }
-
-    return path;
-}
-#endif
-
 SOCKET MegaCmdShellCommunications::createSocket(int number, bool initializeserver, bool net)
 {
     if (net)
@@ -207,6 +185,12 @@ SOCKET MegaCmdShellCommunications::creat
             cerr << "ERROR opening socket: " << ERRNO << endl;
             return INVALID_SOCKET;
         }
+#ifndef _WIN32
+        if (fcntl(thesock, F_SETFD, FD_CLOEXEC) == -1)
+        {
+            cerr << "ERROR setting CLOEXEC to socket: " << errno << endl;
+        }
+#endif
         int portno=MEGACMDINITIALPORTNUMBER+number;
 
         struct sockaddr_in addr;
@@ -315,6 +299,10 @@ SOCKET MegaCmdShellCommunications::creat
             cerr << "ERROR opening socket: " << ERRNO << endl;
             return INVALID_SOCKET;
         }
+        if (fcntl(thesock, F_SETFD, FD_CLOEXEC) == -1)
+        {
+            cerr << "ERROR setting CLOEXEC to socket: " << errno << endl;
+        }
 
         bzero(socket_path, sizeof( socket_path ) * sizeof( *socket_path ));
         if (number)
@@ -346,7 +334,7 @@ SOCKET MegaCmdShellCommunications::creat
                     setsid(); //create new session so as not to receive parent's Ctrl+C
 
                     string pathtolog = createAndRetrieveConfigFolder()+"/megacmdserver.log";
-                    OUTSTREAM << "[Initiating server in background. Log: " << pathtolog << "]" << endl;
+                    CERR << "[Initiating server in background. Log: " << pathtolog << "]" << endl; //TODO: try this in windows with non unicode user name?
 
                     dup2(fileno(stdout), fileno(stderr));  //redirects stderr to stdout below this line.
                     freopen(pathtolog.c_str(),"w",stdout);
@@ -373,7 +361,10 @@ SOCKET MegaCmdShellCommunications::creat
         #endif
     #endif
 #endif
-                    char * args[] = {NULL};
+
+                    char **args = new char*[2];
+                    args[0]=(char *)executable;
+                    args[1] = NULL;
 
                     int ret = execvp(executable,args);
 
@@ -382,6 +373,7 @@ SOCKET MegaCmdShellCommunications::creat
                         cerr << "Couln't initiate MEGAcmd server: executable not found: " << executable << endl;
 #ifdef NDEBUG
                         cerr << "Trying to use alternative executable: " << executable2 << endl;
+                        args[0]=(char *)executable2;
                         ret = execvp(executable2,args);
                         if (ret && errno == 2 )
                         {
@@ -483,7 +475,6 @@ MegaCmdShellCommunications::MegaCmdShell
     stopListener = false;
     updating = false;
     listenerThread = NULL;
-    MegaCmdShellCommunications::megaCmdStdoutputing.init(false);
 }
 
 
@@ -893,7 +884,7 @@ int MegaCmdShellCommunications::readconf
 
 }
 
-int MegaCmdShellCommunications::registerForStateChanges(void (*statechangehandle)(string))
+int MegaCmdShellCommunications::registerForStateChanges(bool interactive, void (*statechangehandle)(string), bool initiateServer)
 {
     if (statechangehandle == NULL)
     {
@@ -901,7 +892,8 @@ int MegaCmdShellCommunications::register
         registerAgainRequired = false;
         return 0; //Do nth
     }
-    SOCKET thesock = createSocket();
+    SOCKET thesock = createSocket(0, initiateServer);
+
     if (thesock == INVALID_SOCKET)
     {
         cerr << "Failed to create socket for registering for state changes" << endl;
@@ -910,10 +902,11 @@ int MegaCmdShellCommunications::register
     }
 
 #ifdef _WIN32
-    wstring wcommand=L"registerstatelistener";
+    wstring wcommand=interactive?L"Xregisterstatelistener":L"registerstatelistener";
     int n = send(thesock,(char*)wcommand.data(),int(wcslen(wcommand.c_str())*sizeof(wchar_t)), MSG_NOSIGNAL);
 #else
-    string command="registerstatelistener";
+    string command=interactive?"Xregisterstatelistener":"registerstatelistener";
+
     int n = send(thesock,command.data(),command.size(), MSG_NOSIGNAL);
 #endif
 
@@ -978,3 +971,4 @@ MegaCmdShellCommunications::~MegaCmdShel
     }
     delete (MegaThread *)listenerThread;
 }
+} //end namespace
--- a/src/megacmdshell/megacmdshellcommunications.h
+++ b/src/megacmdshell/megacmdshellcommunications.h
@@ -26,6 +26,7 @@
 
 #include <string>
 #include <iostream>
+#include <mutex>
 
 #ifdef _WIN32
 #include <WinSock2.h>
@@ -40,15 +41,12 @@
 
 #if defined(_WIN32) && !defined(WINDOWS_PHONE) && !defined(USE_CPPTHREAD)
 #include "mega/thread/win32thread.h"
-class MegaMutex : public ::mega::Win32Mutex {};
 class MegaThread : public ::mega::Win32Thread {};
 #elif defined(USE_CPPTHREAD)
 #include "mega/thread/cppthread.h"
-class MegaMutex : public ::mega::CppMutex {};
 class MegaThread : public ::mega::CppThread {};
 #else
 #include "mega/thread/posixthread.h"
-class MegaMutex : public ::mega::PosixMutex {};
 class MegaThread : public ::mega::PosixThread {};
 #endif
 
@@ -75,6 +73,7 @@ typedef int SOCKET;
 #endif
 
 #define MEGACMDINITIALPORTNUMBER 12300
+namespace megacmd {
 
 enum
 {
@@ -118,11 +117,11 @@ public:
     MegaCmdShellCommunications();
     virtual ~MegaCmdShellCommunications();
 
-    static MegaMutex megaCmdStdoutputing;
+    static std::mutex megaCmdStdoutputing;
     virtual int executeCommand(std::string command, std::string (*readresponse)(const char *) = NULL, OUTSTREAMTYPE &output = COUT, bool interactiveshell = true, std::wstring = L"");
     virtual int executeCommandW(std::wstring command, std::string (*readresponse)(const char *) = NULL, OUTSTREAMTYPE &output = COUT, bool interactiveshell = true);
 
-    virtual int registerForStateChanges(void (*statechangehandle)(std::string) = NULL);
+    virtual int registerForStateChanges(bool interactive, void (*statechangehandle)(std::string) = NULL, bool initiateServer = true);
 
     virtual void setResponseConfirmation(bool confirmation);
 
@@ -143,7 +142,7 @@ private:
     static bool confirmResponse;
 
     static bool stopListener;
-    static mega::Thread *listenerThread;
+    static MegaThread *listenerThread;
 
 #ifdef _WIN32
 static SOCKET createSocket(int number = 0, bool initializeserver = true, bool net = true);
@@ -154,4 +153,5 @@ static SOCKET createSocket(int number =
 
 };
 
+}//end namespace
 #endif // MEGACMDSHELLCOMMUNICATIONS_H
--- a/src/megacmdshell/megacmdshellcommunicationsnamedpipes.cpp
+++ b/src/megacmdshell/megacmdshellcommunicationsnamedpipes.cpp
@@ -31,6 +31,7 @@
 #include <Aclapi.h> //GetSecurityInfo
 #include <Sddl.h> //ConvertSidToStringSid
 
+#include <algorithm>
 
 #include <fcntl.h>
 #include <io.h>
@@ -42,6 +43,8 @@
 #define _O_U8TEXT 0x00040000
 #endif
 
+namespace megacmd {
+
 bool MegaCmdShellCommunicationsNamedPipes::confirmResponse; //TODO: do all this only in parent class
 bool MegaCmdShellCommunicationsNamedPipes::stopListener;
 mega::Thread *MegaCmdShellCommunicationsNamedPipes::listenerThread;
@@ -586,7 +589,7 @@ int MegaCmdShellCommunicationsNamedPipes
                 char buffer[10025];
                 do{
                     BOOL readok;
-                    readok = ReadFile(newNamedPipe, buffer, min(BUFFERSIZE,partialoutsize),&n,NULL);
+                    readok = ReadFile(newNamedPipe, buffer, std::min(BUFFERSIZE,partialoutsize),&n,NULL);
                     if (readok)
                     {
 
@@ -820,20 +823,20 @@ int MegaCmdShellCommunicationsNamedPipes
     return 0;
 }
 
-int MegaCmdShellCommunicationsNamedPipes::registerForStateChanges(void (*statechangehandle)(string))
+int MegaCmdShellCommunicationsNamedPipes::registerForStateChanges(bool interactive, void (*statechangehandle)(string), bool initiateServer)
 {
     if (statechangehandle == NULL)
     {
         registerAgainRequired = false;
         return 0; //Do nth
     }
-    HANDLE theNamedPipe = createNamedPipe();
+    HANDLE theNamedPipe = createNamedPipe(0, initiateServer);
     if (!namedPipeValid(theNamedPipe))
     {
         return -1;
     }
 
-    wstring wcommand=L"registerstatelistener";
+    wstring wcommand=interactive?L"Xregisterstatelistener":L"registerstatelistener";
 
     DWORD n;
     if (!WriteFile(theNamedPipe,(char *)wcommand.data(),DWORD(wcslen(wcommand.c_str())*sizeof(wchar_t)), &n, NULL))
@@ -887,4 +890,6 @@ MegaCmdShellCommunicationsNamedPipes::~M
     }
     delete (MegaThread *)listenerThread;
 }
+
+} //end namespace
 #endif
--- a/src/megacmdshell/megacmdshellcommunicationsnamedpipes.h
+++ b/src/megacmdshell/megacmdshellcommunicationsnamedpipes.h
@@ -36,6 +36,7 @@
 
 #include <Shlwapi.h> //PathAppend
 
+namespace megacmd {
 typedef struct structListenStateChangesNamedPipe{
     int receiveNamedPipeNum;
     void (*statechangehandle)(std::string);
@@ -56,7 +57,7 @@ public:
     virtual int executeCommand(std::string command, std::string (*readresponse)(const char *) = NULL, OUTSTREAMTYPE &output = COUT, bool interactiveshell = true, std::wstring = L"");
     virtual int executeCommandW(std::wstring command, std::string (*readresponse)(const char *) = NULL, OUTSTREAMTYPE &output = COUT, bool interactiveshell = true);
 
-    virtual int registerForStateChanges(void (*statechangehandle)(std::string) = NULL);
+    virtual int registerForStateChanges(bool interactive, void (*statechangehandle)(std::string) = NULL, bool initiateServer = true);
 
     void setResponseConfirmation(bool confirmation);
 
@@ -82,5 +83,6 @@ private:
 
 };
 
+}//end namespace
 #endif
 #endif // MEGACMDSHELLCOMMUNICATIONS_H
--- a/src/megacmdshell/megacmdshell.cpp
+++ b/src/megacmdshell/megacmdshell.cpp
@@ -32,11 +32,14 @@
 #include <iomanip>
 #include <string>
 #include <cstring>
+#include <mutex>
+#include <condition_variable>
 #include <set>
 #include <map>
 #include <vector>
 #include <sstream>
 #include <algorithm>
+#include <atomic>
 #include <stdio.h>
 
 #define PROGRESS_COMPLETE -2
@@ -66,9 +69,11 @@
 #define SSTR( x ) static_cast< const std::ostringstream & >( \
         (  std::ostringstream() << std::dec << x ) ).str()
 
-using namespace std;
 using namespace mega;
 
+namespace megacmd {
+using namespace std;
+
 #if defined(NO_READLINE) && defined(_WIN32)
 CONSOLE_CLASS* console = NULL;
 #endif
@@ -171,12 +176,18 @@ string newpasswd;
 
 bool doExit = false;
 bool doReboot = false;
-bool handlerinstalled = false;
+static std::atomic_bool handlerOverridenByExternalThread(false);
+static std::mutex handlerInstallerMutex;
 
-bool requirepromptinstall = true;
+static std::atomic_bool requirepromptinstall(true);
 
 bool procesingline = false;
 
+std::mutex promptLogReceivedMutex;
+std::condition_variable promtpLogReceivedCV;
+bool promtpLogReceivedBool = false;
+bool serverTryingToLog = false;
+
 
 static char dynamicprompt[PROMPT_MAX_SIZE];
 
@@ -199,16 +210,21 @@ bool confirmingcancellink = false;
 // communications with megacmdserver:
 MegaCmdShellCommunications *comms;
 
-MUTEX_CLASS mutexPrompt(false);
+std::mutex mutexPrompt;
 
 void printWelcomeMsg(unsigned int width = 0);
 
+void install_rl_handler(const char *theprompt, bool external = true);
+
 void statechangehandle(string statestring)
 {
     char statedelim[2]={(char)0x1F,'\0'};
     size_t nextstatedelimitpos = statestring.find(statedelim);
     static bool shown_partial_progress = false;
 
+    unsigned int width = getNumberOfCols(75);
+    if (width > 1 ) width--;
+
     while (nextstatedelimitpos!=string::npos && statestring.size())
     {
         string newstate = statestring.substr(0,nextstatedelimitpos);
@@ -216,7 +232,17 @@ void statechangehandle(string statestrin
         nextstatedelimitpos = statestring.find(statedelim);
         if (newstate.compare(0, strlen("prompt:"), "prompt:") == 0)
         {
+            if (serverTryingToLog)
+            {
+                std::unique_lock<std::mutex> lk(MegaCmdShellCommunications::megaCmdStdoutputing);
+                printCenteredContentsCerr(string(" Server is still trying to log in. Still, some commands are available.\n"
+                             "Type \"help\", to list them.").c_str(), width);
+            }
             changeprompt(newstate.substr(strlen("prompt:")).c_str(),true);
+
+            std::unique_lock<std::mutex> lk(promptLogReceivedMutex);
+            promtpLogReceivedCV.notify_one();
+            promtpLogReceivedBool = true;
         }
         else if (newstate.compare(0, strlen("endtransfer:"), "endtransfer:") == 0)
         {
@@ -246,15 +272,23 @@ void statechangehandle(string statestrin
 #endif
             }
         }
+        else if (newstate.compare(0, strlen("loged:"), "loged:") == 0)
+        {
+            serverTryingToLog = false;
+        }
+        else if (newstate.compare(0, strlen("login:"), "login:") == 0)
+        {
+            serverTryingToLog = true;
+            std::unique_lock<std::mutex> lk(MegaCmdShellCommunications::megaCmdStdoutputing);
+            printCenteredContentsCerr(string("Resuming session ... ").c_str(), width, false);
+        }
         else if (newstate.compare(0, strlen("message:"), "message:") == 0)
         {
-            string contents = newstate.substr(strlen("message:"));
-            unsigned int width = getNumberOfCols(75);
-            if (width > 1 ) width--;
             MegaCmdShellCommunications::megaCmdStdoutputing.lock();
 #ifdef _WIN32
             int oldmode = _setmode(_fileno(stdout), _O_U8TEXT);
 #endif
+            string contents = newstate.substr(strlen("message:"));
             if (contents.find("-----") != 0)
             {
                 if (!procesingline || shown_partial_progress)
@@ -262,6 +296,10 @@ void statechangehandle(string statestrin
                     OUTSTREAM << endl;
                 }
                 printCenteredContents(contents, width);
+                if (prompt == COMMAND && promtpLogReceivedBool)
+                {
+                    install_rl_handler(*dynamicprompt ? dynamicprompt : prompts[COMMAND]);
+                }
             }
             else
             {
@@ -582,8 +620,10 @@ wstring escapereadlinebreakers(const wch
 #endif
 
 #ifndef NO_READLINE
-void install_rl_handler(const char *theprompt)
+void install_rl_handler(const char *theprompt, bool external)
 {
+    std::lock_guard<std::mutex> lkrlhandler(handlerInstallerMutex);
+
 #ifdef _WIN32
     wstring wswhat;
     stringtolocalw(theprompt,&wswhat);
@@ -620,14 +660,18 @@ void install_rl_handler(const char *thep
     }
 
 #else
+
     rl_callback_handler_install(theprompt, store_line);
+    handlerOverridenByExternalThread = external;
+    requirepromptinstall = false;
+
 #endif
 }
 #endif
 
 void changeprompt(const char *newprompt, bool redisplay)
 {
-    MutexGuard g(mutexPrompt);
+    std::lock_guard<std::mutex> g(mutexPrompt);
 
     if (*dynamicprompt)
     {
@@ -664,7 +708,10 @@ void changeprompt(const char *newprompt,
             rl_crlf();
         }
 
-        install_rl_handler(*dynamicprompt ? dynamicprompt : prompts[COMMAND]);
+        if (prompt == COMMAND)
+        {
+            install_rl_handler(*dynamicprompt ? dynamicprompt : prompts[COMMAND]);
+        }
 
         // restore line
         if (saved_line)
@@ -676,9 +723,7 @@ void changeprompt(const char *newprompt,
         rl_point = saved_point;
         rl_redisplay();
 
-        handlerinstalled = true;
 
-        requirepromptinstall = false;
     }
 
 #endif
@@ -1335,6 +1380,24 @@ void process_line(const char * line)
 #endif
 
             vector<string> words = getlistOfWords((char *)line);
+
+            string clientWidth = "--client-width=";
+            clientWidth+= SSTR(getNumberOfCols(80));
+
+            words.insert(words.begin()+1, clientWidth);
+
+            string scommandtoexec(words[0]);
+            scommandtoexec+=" ";
+            scommandtoexec+=clientWidth;
+            scommandtoexec+=" ";
+
+            if (strlen(line)>(words[0].size()+1))
+            {
+                scommandtoexec+=line+words[0].size()+1;
+            }
+
+            const char *commandtoexec = scommandtoexec.c_str();
+
             bool helprequested = false;
             for (unsigned int i = 1; i< words.size(); i++)
             {
@@ -1344,15 +1407,13 @@ void process_line(const char * line)
             {
                 if ( words[0] == "exit" || words[0] == "quit")
                 {
-                    if (words.size() == 1)
+                    if (find(words.begin(), words.end(), "--only-shell") == words.end())
                     {
-                        doExit = true;
-                    }
-                    if (words.size() == 1 || words[1]!="--only-shell")
-                    {
-                        comms->executeCommand(line, readresponse);
+                        comms->executeCommand(commandtoexec, readresponse);
                     }
-                    else
+
+                    if (find(words.begin(), words.end(), "--help") == words.end()
+                            && find(words.begin(), words.end(), "--only-server") == words.end() )
                     {
                         doExit = true;
                     }
@@ -1361,7 +1422,7 @@ void process_line(const char * line)
                 else if (words[0] == "update")
                 {
                     MegaCmdShellCommunications::updating = true;
-                    int ret = comms->executeCommand(line, readresponse);
+                    int ret = comms->executeCommand(commandtoexec, readresponse);
                     if (ret == MCMD_REQRESTART)
                     {
                         OUTSTREAM << "MEGAcmd has been updated ... this shell will be restarted before proceding...." << endl;
@@ -1397,7 +1458,7 @@ void process_line(const char * line)
                 {
                     if (isserverloggedin())
                     {
-                        passwdline = line;
+                        passwdline = commandtoexec;
                         discardOptionsAndFlags(&words);
                         if (words.size() == 1)
                         {
@@ -1405,7 +1466,7 @@ void process_line(const char * line)
                         }
                         else
                         {
-                            comms->executeCommand(line, readresponse);
+                            comms->executeCommand(commandtoexec, readresponse);
                         }
                     }
                     else
@@ -1429,12 +1490,12 @@ void process_line(const char * line)
                         }
                         else
                         {
-                            string s = line;
+                            string s = commandtoexec;
                             if (clientID.size())
                             {
                                 s = "login --clientID=";
                                 s+=clientID;
-                                s.append(string(line).substr(5));
+                                s.append(string(commandtoexec).substr(5));
                             }
                             comms->executeCommand(s, readresponse);
                         }
@@ -1449,7 +1510,7 @@ void process_line(const char * line)
                 {
                     if (!isserverloggedin())
                     {
-                        signupline = line;
+                        signupline = commandtoexec;
                         discardOptionsAndFlags(&words);
 
                         if (words.size() == 2)
@@ -1460,7 +1521,7 @@ void process_line(const char * line)
                         }
                         else
                         {
-                            comms->executeCommand(line, readresponse);
+                            comms->executeCommand(commandtoexec, readresponse);
                         }
                     }
                     else
@@ -1482,7 +1543,7 @@ void process_line(const char * line)
                     }
                     else
                     {
-                        comms->executeCommand(line, readresponse);
+                        comms->executeCommand(commandtoexec, readresponse);
                     }
                 }
                 else if (!helprequested && words[0] == "confirmcancel")
@@ -1497,7 +1558,7 @@ void process_line(const char * line)
                     }
                     else
                     {
-                        comms->executeCommand(line, readresponse);
+                        comms->executeCommand(commandtoexec, readresponse);
                     }
                     return;
                 }
@@ -1536,7 +1597,7 @@ void process_line(const char * line)
                 {
                     string toexec;
 
-                    if (!strstr (line,"path-display-size"))
+                    if (!strstr (commandtoexec,"path-display-size"))
                     {
                         unsigned int width = getNumberOfCols(75);
                         int pathSize = int((width-46)/2);
@@ -1545,14 +1606,14 @@ void process_line(const char * line)
                         toexec+=" --path-display-size=";
                         toexec+=SSTR(pathSize);
                         toexec+=" ";
-                        if (strlen(line)>(words[0].size()+1))
+                        if (strlen(commandtoexec)>(words[0].size()+1))
                         {
-                            toexec+=line+words[0].size()+1;
+                            toexec+=commandtoexec+words[0].size()+1;
                         }
                     }
                     else
                     {
-                        toexec+=line;
+                        toexec+=commandtoexec;
                     }
 
                     comms->executeCommand(toexec.c_str(), readresponse);
@@ -1561,11 +1622,11 @@ void process_line(const char * line)
                 {
                     string toexec;
 
-                    if (!strstr (line,"path-display-size"))
+                    if (!strstr (commandtoexec,"path-display-size"))
                     {
                         unsigned int width = getNumberOfCols(75);
                         int pathSize = int(width-13);
-                        if (strstr(line, "--versions"))
+                        if (strstr(commandtoexec, "--versions"))
                         {
                             pathSize -= 11;
                         }
@@ -1574,14 +1635,14 @@ void process_line(const char * line)
                         toexec+=" --path-display-size=";
                         toexec+=SSTR(pathSize);
                         toexec+=" ";
-                        if (strlen(line)>(words[0].size()+1))
+                        if (strlen(commandtoexec)>(words[0].size()+1))
                         {
-                            toexec+=line+words[0].size()+1;
+                            toexec+=commandtoexec+words[0].size()+1;
                         }
                     }
                     else
                     {
-                        toexec+=line;
+                        toexec+=commandtoexec;
                     }
 
                     comms->executeCommand(toexec.c_str(), readresponse);
@@ -1590,7 +1651,7 @@ void process_line(const char * line)
                 {
                     string toexec;
 
-                    if (!strstr (line,"path-display-size"))
+                    if (!strstr (commandtoexec,"path-display-size"))
                     {
                         unsigned int width = getNumberOfCols(75);
                         int pathSize = int((width-46)/2);
@@ -1598,14 +1659,14 @@ void process_line(const char * line)
                         toexec+="sync --path-display-size=";
                         toexec+=SSTR(pathSize);
                         toexec+=" ";
-                        if (strlen(line)>strlen("sync "))
+                        if (strlen(commandtoexec)>strlen("sync "))
                         {
-                            toexec+=line+strlen("sync ");
+                            toexec+=commandtoexec+strlen("sync ");
                         }
                     }
                     else
                     {
-                        toexec+=line;
+                        toexec+=commandtoexec;
                     }
 
                     comms->executeCommand(toexec.c_str(), readresponse);
@@ -1614,7 +1675,7 @@ void process_line(const char * line)
                 {
                     string toexec;
 
-                    if (!strstr (line,"path-display-size"))
+                    if (!strstr (commandtoexec,"path-display-size"))
                     {
                         unsigned int width = getNumberOfCols(75);
                         int pathSize = int(width - 28);
@@ -1623,14 +1684,14 @@ void process_line(const char * line)
                         toexec+=" --path-display-size=";
                         toexec+=SSTR(pathSize);
                         toexec+=" ";
-                        if (strlen(line)>(words[0].size()+1))
+                        if (strlen(commandtoexec)>(words[0].size()+1))
                         {
-                            toexec+=line+words[0].size()+1;
+                            toexec+=commandtoexec+words[0].size()+1;
                         }
                     }
                     else
                     {
-                        toexec+=line;
+                        toexec+=commandtoexec;
                     }
 
                     comms->executeCommand(toexec.c_str(), readresponse);
@@ -1639,7 +1700,7 @@ void process_line(const char * line)
                 {
                     string toexec;
 
-                    if (!strstr (line,"path-display-size"))
+                    if (!strstr (commandtoexec,"path-display-size"))
                     {
                         unsigned int width = getNumberOfCols(75);
                         int pathSize = int((width-21)/2);
@@ -1647,14 +1708,14 @@ void process_line(const char * line)
                         toexec+="backup --path-display-size=";
                         toexec+=SSTR(pathSize);
                         toexec+=" ";
-                        if (strlen(line)>strlen("backup "))
+                        if (strlen(commandtoexec)>strlen("backup "))
                         {
-                            toexec+=line+strlen("backup ");
+                            toexec+=commandtoexec+strlen("backup ");
                         }
                     }
                     else
                     {
-                        toexec+=line;
+                        toexec+=commandtoexec;
                     }
 
                     comms->executeCommand(toexec.c_str(), readresponse);
@@ -1663,10 +1724,10 @@ void process_line(const char * line)
                 {
                     if ( words[0] == "get" || words[0] == "put" || words[0] == "reload")
                     {
-                        string s = line;
+                        string s = commandtoexec;
                         if (clientID.size())
                         {
-                            string sline = line;
+                            string sline = commandtoexec;
                             size_t pspace = sline.find_first_of(" ");
                             s="";
                             s=sline.substr(0,pspace);
@@ -1686,13 +1747,13 @@ void process_line(const char * line)
                     else
                     {
                         // execute user command
-                        comms->executeCommand(line, readresponse);
+                        comms->executeCommand(commandtoexec, readresponse);
                     }
                 }
             }
             else
             {
-                cerr << "failed to interprete input line: " << line << endl;
+                cerr << "failed to interprete input commandtoexec: " << commandtoexec << endl;
             }
             break;
         }
@@ -1716,10 +1777,22 @@ void readloop()
     readline_fd = fileno(rl_instream);
 
     procesingline = true;
-    comms->registerForStateChanges(statechangehandle);
+    comms->registerForStateChanges(true, statechangehandle);
+
+
+    //now we can relay on having a prompt received if the server is running
+    {
+        std::unique_lock<std::mutex> lk(promptLogReceivedMutex);
+        if (!promtpLogReceivedBool)
+        {
+            if (promtpLogReceivedCV.wait_for(lk, std::chrono::seconds(2*RESUME_SESSION_TIMEOUT)) == std::cv_status::timeout)
+            {
+                std::cerr << "Server seems irresponsive" << endl;
+            }
+        }
+    }
+
 
-    //give it a while to communicate the state
-    sleepMilliSeconds(700);
     procesingline = false;
 
 #if defined(_WIN32) && defined(USE_PORT_COMMS)
@@ -1727,7 +1800,7 @@ void readloop()
     // in windows we would not be yet connected. we need to manually try to register again.
     if (comms->registerAgainRequired)
     {
-        comms->registerForStateChanges(statechangehandle);
+        comms->registerForStateChanges(true, statechangehandle);
     }
     //give it a while to communicate the state
     sleepMilliSeconds(1);
@@ -1740,9 +1813,7 @@ void readloop()
             mutexPrompt.lock();
             if (requirepromptinstall)
             {
-                install_rl_handler(*dynamicprompt ? dynamicprompt : prompts[COMMAND]);
-
-                handlerinstalled = false;
+                install_rl_handler(*dynamicprompt ? dynamicprompt : prompts[COMMAND], false);
 
                 // display prompt
                 if (saved_line)
@@ -1769,6 +1840,8 @@ void readloop()
 
                 wait_for_input(readline_fd);
 
+                std::lock_guard<std::mutex> g(mutexPrompt);
+
                 rl_callback_read_char(); //this calls store_line if last char was enter
 
                 time_t tnow = time(NULL);
@@ -1805,6 +1878,7 @@ void readloop()
 
         }
 
+        mutexPrompt.lock();
         // save line
         saved_point = rl_point;
         if (saved_line != NULL)
@@ -1816,21 +1890,31 @@ void readloop()
         rl_replace_line("", 0);
         rl_redisplay();
 
+        mutexPrompt.unlock();
         if (line)
         {
             if (strlen(line))
             {
                 alreadyFinished = false;
                 percentDowloaded = 0.0;
-//                mutexPrompt.lock();
+
+                handlerOverridenByExternalThread = false;
                 process_line(line);
-                requirepromptinstall = true;
-//                mutexPrompt.unlock();
+
+                {
+                    //after processing the line, we want to reinstall the handler (except if during the process, or due to it,
+                    // the handler is reinstalled by e.g: a change in prompt)
+                    std::lock_guard<std::mutex> lkrlhandler(handlerInstallerMutex);
+                    if (!handlerOverridenByExternalThread)
+                    {
+                        requirepromptinstall = true;
+                    }
+                }
 
                 if (comms->registerAgainRequired)
                 {
                     // register again for state changes
-                     comms->registerForStateChanges(statechangehandle);
+                     comms->registerForStateChanges(true, statechangehandle);
                      comms->registerAgainRequired = false;
                 }
 
@@ -1855,7 +1939,7 @@ void readloop()
 {
     time_t lasttimeretrycons = 0;
 
-    comms->registerForStateChanges(statechangehandle);
+    comms->registerForStateChanges(true, statechangehandle);
 
     //give it a while to communicate the state
     sleepMilliSeconds(700);
@@ -1865,7 +1949,7 @@ void readloop()
     // in windows we would not be yet connected. we need to manually try to register again.
     if (comms->registerAgainRequired)
     {
-        comms->registerForStateChanges(statechangehandle);
+        comms->registerForStateChanges(true, statechangehandle);
     }
     //give it a while to communicate the state
     sleepMilliSeconds(1);
@@ -1922,7 +2006,7 @@ void readloop()
                 if (comms->registerAgainRequired)
                 {
                     // register again for state changes
-                    comms->registerForStateChanges(statechangehandle);
+                    comms->registerForStateChanges(true, statechangehandle);
                     comms->registerAgainRequired = false;
                 }
 
@@ -2100,6 +2184,9 @@ std::string readresponse(const char* que
 }
 #endif
 
+} //end namespace
+
+using namespace megacmd;
 
 int main(int argc, char* argv[])
 {
@@ -2195,6 +2282,14 @@ int main(int argc, char* argv[])
             COUT << "Unable to execute: " << szPathExec << " errno = : " << ERRNO << endl;
             sleepSeconds(5);
         }
+#elif defined(__linux__)
+        system("reset -I");
+        string executable = argv[0];
+        if (executable.find("/") != 0)
+        {
+            executable.insert(0, getCurrentExecPath()+"/");
+        }
+        execv(executable.c_str(), argv);
 #else
         system("reset -I");
         execv(argv[0], argv);
--- a/src/megacmdshell/megacmdshell.h
+++ b/src/megacmdshell/megacmdshell.h
@@ -22,6 +22,7 @@
 
 #define OUTSTREAM COUT
 
+namespace megacmd {
 enum prompttype
 {
     COMMAND, LOGINPASSWORD, NEWPASSWORD, PASSWORDCONFIRM, AREYOUSURE
@@ -54,5 +55,6 @@ void printHistory();
 
 std::string readresponse(const char *question);
 
+}//end namespace
 #endif // MEGACMDSHELL_H
 
--- a/src/megacmdutils.cpp
+++ b/src/megacmdutils.cpp
@@ -33,9 +33,9 @@
 #include <fstream>
 #include <time.h>
 
-using namespace std;
 using namespace mega;
 
+namespace megacmd {
 void getNumFolderFiles(MegaNode *n, MegaApi *api, long long *nfiles, long long *nfolders)
 {
     MegaNodeList *totalnodes = api->getChildren(n);
@@ -444,8 +444,38 @@ string backupSatetStr(int backupstate)
 }
 #endif
 
+const char * getProxyTypeStr(int proxyType)
+{
+    switch (proxyType)
+    {
+    case MegaProxy::PROXY_AUTO:
+        return "PROXY_AUTO";
+        break;
+    case MegaProxy::PROXY_NONE:
+        return "PROXY_NONE";
+        break;
+    case MegaProxy::PROXY_CUSTOM:
+        return "PROXY_CUSTOM";
+        break;
+    default:
+        return "INVALID";
+        break;
+    }
+
+}
+
 int getLinkType(string link)
 {
+    if (link.find("/folder/") != string::npos)
+    {
+        return MegaNode::TYPE_FOLDER;
+    }
+
+    if (link.find("/file/") != string::npos)
+    {
+        return MegaNode::TYPE_FILE;
+    }
+
     size_t posHash = link.find_first_of("#");
     if (( posHash == string::npos ) || !( posHash + 1 < link.length()))
     {
@@ -550,7 +580,7 @@ string secondsToText(m_time_t seconds, b
     if (humanreadable)
     {
         m_time_t reducedSize = m_time_t( seconds > 3600 * 2 ? seconds / 3600.0 : ( seconds > 60 * 2 ? seconds / 60.0 : seconds) );
-        os << fixed << reducedSize;
+        os << std::fixed << reducedSize;
         os << ( seconds > 3600 * 2 ? " hours" : ( seconds > 60 * 2 ? " minutes" : " seconds" ));
     }
     else
@@ -1162,6 +1192,11 @@ bool setOptionsAndFlags(map<string, stri
                     }
                 }
             }
+            else if (w == "--")
+            {
+                it = ws->erase(it);
+                return discarded; // cease to look for options & leave the rest
+            }
             else if (w.find_first_of("=") == std::string::npos) //flag
             {
                 string optname = ltrim(w, '-');
@@ -1239,3 +1274,5 @@ int permissionsFromReadable(string permi
     return -1;
 }
 #endif
+
+}//end namespace
--- a/src/megacmdutils.h
+++ b/src/megacmdutils.h
@@ -24,6 +24,7 @@
 
 #include <string>
 
+namespace megacmd {
 using ::mega::m_time_t;
 
 /* mega::MegaNode info extracting*/
@@ -57,6 +58,7 @@ const char * getTransferStateStr(int tra
 
 std::string backupSatetStr(int backupstate);
 
+const char * getProxyTypeStr(int proxyType);
 
 /* Files and folders */
 
@@ -122,4 +124,5 @@ bool getMinAndMaxSize(std::string sizest
 std::string readablePermissions(int permvalue);
 int permissionsFromReadable(std::string permissions);
 
+}//end namespace
 #endif // MEGACMDUTILS_H
--- a/src/megacmdversion.h
+++ b/src/megacmdversion.h
@@ -5,40 +5,47 @@
 #define MEGACMD_MAJOR_VERSION 1
 #endif
 #ifndef MEGACMD_MINOR_VERSION
-#define MEGACMD_MINOR_VERSION 1
+#define MEGACMD_MINOR_VERSION 2
 #endif
 #ifndef MEGACMD_MICRO_VERSION
 #define MEGACMD_MICRO_VERSION 0
 #endif
 
+#ifndef MEGACMD_BUILD_ID
+#define MEGACMD_BUILD_ID 0
+#endif
+
 #ifndef MEGACMD_CODE_VERSION
-#define MEGACMD_CODE_VERSION (MEGACMD_MICRO_VERSION*100+MEGACMD_MINOR_VERSION*10000+MEGACMD_MAJOR_VERSION*1000000)
+#define MEGACMD_CODE_VERSION (MEGACMD_BUILD_ID+MEGACMD_MICRO_VERSION*100+MEGACMD_MINOR_VERSION*10000+MEGACMD_MAJOR_VERSION*1000000)
 #endif
+namespace megacmd {
 
 const char * const megacmdchangelog =
-        "added \"cat\" command to read text files (and potentially stream any file)""\n"
-        "added update capabilities for Windows & MacOS (automatic updates are enabled by default)""\n"
-        "added \"media-info\" command to show some information of multimedia files""\n"
-        "added \"df\" command to show storage info""\n"
-        "added tree-like listing command: \"tree\" or \"ls --tree\"""\n"
-        "shown progress in non-interactive mode""\n"
-        "improvements in progress and transfers results information""\n"
-        "width output adjustments in non-interactive mode""\n"
-        "output streamed partially from server to clients""\n"
-        "added --time-format option to commands displaying times, to allow other formats""\n"
-        "2FA login auth code can be passed as parameter now""\n"
-        "transfer now differentiate backup transfers""\n"
-        "backup command completion for local paths now only looks for folders""\n"
-        "backup transfers are no longer cached (no reason to: backups are considered failed in such case)""\n"
-        "backup fix some halts and output improvements""\n"
-        "added Public Service Announcements (PSA) support""\n"
-        "killsession now allows multiple parameters""\n"
-        "fix \"clear\" in some linuxes""\n"
-        "add support for spaces in password prompts""\n"
-        "many more minor fixes & adjustments"
+        "\"put\" now supports wildcard expressions""\n"
+        "support setting a proxy with \"proxy\" command""\n"
+        "add support for addressing inshares with //from/""\n"
+        "support for files/folders within public links""\n"
+        "minor fix for ls --tree autocompletion""\n"
+        "discard flags/options after \"--\"""\n"
+        "--show-handles option added in ls & find""\n"
+        "files/folders can be addressed using their handle H:XXXXXXX""\n"
+        "support new links format""\n"
+        "fixes in reported used storage""\n"
+        "fix crash in find command""\n"
+        "do not consider inshares for version storage used""\n"
+        "win installer: do not ask for elevate permissions when running in silent mode""\n"
+        "improved columned outputs to maximize screen use (syncs & transfers)""\n"
+        "improve responsiveness at startup in interactive mode, to avoid hangs when session does not resume"
+        "Added mode while logging in that allows certain actions (like setting a proxy)""\n"
+        "non-interactive mode will not wait for commands that can be addressed before the session is resumed""\n"
+
+        "speedup cancellation/startup of a huge number of transfers""\n"
+        "cloud raid support""\n"
+        "speedup improvements in cache and other CPU bottlenecks""\n"
+        "many more fixes & adjustments"
         ;
 
-
+}//end namespace
 #endif // VERSION_H
 
 
--- a/src/updater/MacUtils.h
+++ b/src/updater/MacUtils.h
@@ -2,8 +2,6 @@
 #define MACUTILS_H
 #include <iostream>
 
-using namespace std;
-
-bool downloadFileSynchronously(string url, string path);
+bool downloadFileSynchronously(std::string url, std::string path);
 
 #endif // MACUTILS_H
--- a/src/updater/MacUtils.mm
+++ b/src/updater/MacUtils.mm
@@ -1,7 +1,7 @@
 #include "MacUtils.h"
 #include <Cocoa/Cocoa.h>
 
-bool downloadFileSynchronously(string url, string path)
+bool downloadFileSynchronously(std::string url, std::string path)
 {
     NSString *stringURL = [NSString stringWithCString:url.c_str() encoding:NSUTF8StringEncoding];
     NSURL *myURL = [NSURL URLWithString:stringURL];
--- a/src/updater/MegaUpdater.cpp
+++ b/src/updater/MegaUpdater.cpp
@@ -1,4 +1,5 @@
 #ifdef _WIN32
+#include <winsock2.h>
 #include <Windows.h>
 #include <lzexpand.h>
 #include <shlwapi.h>
@@ -215,6 +216,7 @@ using namespace megacmdupdater;
 #include <stdio.h>
 #include <io.h>
 #include <fcntl.h>
+#include <winsock2.h>
 #include <windows.h>
 #include <locale>
 #include <codecvt>
--- a/src/updater/UpdateTask.cpp
+++ b/src/updater/UpdateTask.cpp
@@ -33,6 +33,8 @@
 using std::string;
 using CryptoPP::Integer;
 
+using namespace std;
+
 enum {
     LOG_LEVEL_FATAL = 0,   // Very severe error event that will presumably lead the application to abort.
     LOG_LEVEL_ERROR,   // Error information but will continue application to keep running.
--- a/tests/megacmd_find_test.py
+++ b/tests/megacmd_find_test.py
@@ -76,7 +76,7 @@ def clear_local_and_remote():
 def compare_and_clear() :
     global currentTest
     if VERBOSE:
-        print "test $currentTest"
+        print "test "+str(currentTest)
     
     megafind=sort(cmd_ef(FIND))
     localfind=sort(find('localUPs'))
--- a/tests/megacmd_get_test.py
+++ b/tests/megacmd_get_test.py
@@ -424,5 +424,12 @@ cmd_ef(GET+' /imported/fileatsub02.txt '
 shutil.copy2('origin/foreign/sub02/fileatsub02.txt','localDls/')
 compare_and_clear()
 
+
+#Test 38 # get from //from/XXX
+cmd_ex(GET+' //from/'+osvar('MEGA_EMAIL_AUX')+':foreign/sub02/fileatsub02.txt '+ABSMEGADLFOLDER+'')
+shutil.copy2('origin/foreign/sub02/fileatsub02.txt','localDls/')
+compare_and_clear()
+
+
 # Clean all
 clean_all()
